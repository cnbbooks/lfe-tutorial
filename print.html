<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js lfe-pdp">

<head>
    <!-- Book generated using mdBook -->
    <meta charset="UTF-8">
    <title>The LFE Tutorial</title>
    
    <meta name="robots" content="noindex" />
    
    


    <!-- Custom HTML head -->
    


    <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
    <meta name="description" content="Getting Started with LFE">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#ffffff" />

    <link rel="icon" href="favicon.svg">
    <link rel="shortcut icon" href="favicon.png">
    <link rel="stylesheet" href="css/variables.css">
    <link rel="stylesheet" href="css/general.css">
    <link rel="stylesheet" href="css/chrome.css">
    <link rel="stylesheet" href="css/print.css" media="print">

    <!-- Fonts -->
    <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
    
    <link rel="stylesheet" href="fonts/fonts.css">
    

    <!-- Highlight.js Stylesheets -->
    <link rel="stylesheet" href="highlight.css">
    <link rel="stylesheet" href="tomorrow-night.css">
    <link rel="stylesheet" href="ayu-highlight.css">

    <!-- Custom theme stylesheets -->
    
    <link rel="stylesheet" href="css/custom.css">
    

    
</head>

<body>
    <!-- Provide site root to javascript -->
    <script type="text/javascript">
        var path_to_root = "";
        var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "lfe-pdp" : "lfe-pdp";
    </script>

    <!-- Work around some values being stored in localStorage wrapped in quotes -->
    <script type="text/javascript">
        try {
            var theme = localStorage.getItem('mdbook-theme');
            var sidebar = localStorage.getItem('mdbook-sidebar');

            if (theme.startsWith('"') && theme.endsWith('"')) {
                localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
            }

            if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
            }
        } catch (e) { }
    </script>

    <!-- Set the theme before any content is loaded, prevents flash -->
    <script type="text/javascript">
        var theme;
        try { theme = localStorage.getItem('mdbook-theme'); } catch (e) { }
        if (theme === null || theme === undefined) { theme = default_theme; }
        var html = document.querySelector('html');
        html.classList.remove('no-js')
        html.classList.remove('lfe-pdp')
        html.classList.add(theme);
        html.classList.add('js');
    </script>

    <!-- Hide / unhide sidebar before it is displayed -->
    <script type="text/javascript">
        var html = document.querySelector('html');
        var sidebar = 'hidden';
        if (document.body.clientWidth >= 1080) {
            try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch (e) { }
            sidebar = sidebar || 'visible';
        }
        html.classList.remove('sidebar-visible');
        html.classList.add("sidebar-" + sidebar);
    </script>

    <nav id="sidebar" class="sidebar" aria-label="Table of contents">
        <div class="sidebar-scrollbox">
            <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> The LFE Tutorial</a></li><li class="chapter-item expanded "><a href="front/copyright-page.html"><strong aria-hidden="true">2.</strong> Copyright Page</a></li><li class="chapter-item expanded "><a href="introduction/index.html"><strong aria-hidden="true">3.</strong> Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="introduction/erlang.html"><strong aria-hidden="true">3.1.</strong> About Erlang</a></li><li class="chapter-item expanded "><a href="introduction/lfe.html"><strong aria-hidden="true">3.2.</strong> About LFE</a></li><li class="chapter-item expanded "><a href="introduction/deps.html"><strong aria-hidden="true">3.3.</strong> Dependencies</a></li><li class="chapter-item expanded "><a href="introduction/install.html"><strong aria-hidden="true">3.4.</strong> Installing LFE</a></li></ol></li><li class="chapter-item expanded "><a href="sequential/index.html"><strong aria-hidden="true">4.</strong> Sequential Programming</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="sequential/repl.html"><strong aria-hidden="true">4.1.</strong> The REPL</a></li><li class="chapter-item expanded "><a href="sequential/modfunc.html"><strong aria-hidden="true">4.2.</strong> Modules and Functions</a></li><li class="chapter-item expanded "><a href="sequential/atoms.html"><strong aria-hidden="true">4.3.</strong> Atoms</a></li><li class="chapter-item expanded "><a href="sequential/tuples.html"><strong aria-hidden="true">4.4.</strong> Tuples</a></li><li class="chapter-item expanded "><a href="sequential/lists.html"><strong aria-hidden="true">4.5.</strong> Lists</a></li><li class="chapter-item expanded "><a href="sequential/propmaps.html"><strong aria-hidden="true">4.6.</strong> Property Lists and Maps</a></li><li class="chapter-item expanded "><a href="sequential/stdlib.html"><strong aria-hidden="true">4.7.</strong> The Erlang Standard Library</a></li><li class="chapter-item expanded "><a href="sequential/output.html"><strong aria-hidden="true">4.8.</strong> Writing Output to a Terminal</a></li><li class="chapter-item expanded "><a href="sequential/example.html"><strong aria-hidden="true">4.9.</strong> Example: Converting Temperature</a></li><li class="chapter-item expanded "><a href="sequential/matching.html"><strong aria-hidden="true">4.10.</strong> Matching, Guards and Scope of Variables</a></li><li class="chapter-item expanded "><a href="sequential/morelists.html"><strong aria-hidden="true">4.11.</strong> More About Lists</a></li><li class="chapter-item expanded "><a href="sequential/conds.html"><strong aria-hidden="true">4.12.</strong> Conditionals</a></li><li class="chapter-item expanded "><a href="sequential/bifs.html"><strong aria-hidden="true">4.13.</strong> Built-in Functions</a></li><li class="chapter-item expanded "><a href="sequential/hofs.html"><strong aria-hidden="true">4.14.</strong> Higher Order Functions</a></li></ol></li><li class="chapter-item expanded "><a href="concurrent/index.html"><strong aria-hidden="true">5.</strong> Concurrent Programming</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="concurrent/processes.html"><strong aria-hidden="true">5.1.</strong> Processes</a></li><li class="chapter-item expanded "><a href="concurrent/msgpass.html"><strong aria-hidden="true">5.2.</strong> Message Passing</a></li><li class="chapter-item expanded "><a href="concurrent/names.html"><strong aria-hidden="true">5.3.</strong> Registered Process Names</a></li><li class="chapter-item expanded "><a href="concurrent/dist.html"><strong aria-hidden="true">5.4.</strong> Distributed Programming</a></li><li class="chapter-item expanded "><a href="concurrent/example.html"><strong aria-hidden="true">5.5.</strong> Example: Messenger</a></li></ol></li><li class="chapter-item expanded "><a href="robust/index.html"><strong aria-hidden="true">6.</strong> Robustness</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="robust/timeouts.html"><strong aria-hidden="true">6.1.</strong> Timeouts</a></li><li class="chapter-item expanded "><a href="robust/errors.html"><strong aria-hidden="true">6.2.</strong> Error Handling</a></li><li class="chapter-item expanded "><a href="robust/example.html"><strong aria-hidden="true">6.3.</strong> Example: Robust Messenger</a></li></ol></li><li class="chapter-item expanded "><a href="records/index.html"><strong aria-hidden="true">7.</strong> Records</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="records/mods.html"><strong aria-hidden="true">7.1.</strong> Modularising</a></li><li class="chapter-item expanded "><a href="records/headers.html"><strong aria-hidden="true">7.2.</strong> Header Files</a></li><li class="chapter-item expanded "><a href="records/records.html"><strong aria-hidden="true">7.3.</strong> Records</a></li></ol></li><li class="chapter-item expanded "><a href="macros/index.html"><strong aria-hidden="true">8.</strong> Macros</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="macros/eval.html"><strong aria-hidden="true">8.1.</strong> Eval</a></li><li class="chapter-item expanded "><a href="macros/macros.html"><strong aria-hidden="true">8.2.</strong> Macros</a></li><li class="chapter-item expanded "><a href="macros/backquote.html"><strong aria-hidden="true">8.3.</strong> The Backquote Macro</a></li></ol></li><li class="chapter-item expanded "><a href="conclusion/index.html"><strong aria-hidden="true">9.</strong> Conclusion</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><a href="feedback.html">Feedback</a></li><li class="chapter-item expanded affix "><a href="redirects/docs.html">LFE Documentation</a></li><li class="chapter-item expanded affix "><a href="redirects/mdbook.html">Built with mdBook</a></li></ol>
        </div>
        <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
    </nav>

    <div id="page-wrapper" class="page-wrapper">

        <div class="page">
            
            <div id="menu-bar-hover-placeholder"></div>
            <div id="menu-bar" class="menu-bar sticky bordered">
                <div class="left-buttons">
                    <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents"
                        aria-label="Toggle Table of Contents" aria-controls="sidebar">
                        <i class="fa fa-bars"></i>
                    </button>
                    <button id="theme-toggle" class="icon-button" type="button" title="Change theme"
                        aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                        <i class="fa fa-paint-brush"></i>
                    </button>
                    <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                        <li role="none"><button role="menuitem" class="theme"
                                id="lfe-pdp">LFE PDP</button></li>
                        <li role="none"><button role="menuitem" class="theme"
                                id="light">Light</button></li>
                        <li role="none"><button role="menuitem" class="theme"
                                id="rust">Rust</button></li>
                        <li role="none"><button role="menuitem" class="theme"
                                id="coal">Coal</button></li>
                        <li role="none"><button role="menuitem" class="theme"
                                id="navy">Navy</button></li>
                        <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button>
                        </li>
                    </ul>
                    
                    <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)"
                        aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S"
                        aria-controls="searchbar">
                        <i class="fa fa-search"></i>
                    </button>
                    
                </div>

                <h1 class="menu-title">The LFE Tutorial</h1>

                <div class="right-buttons">
                    <a href="print.html" title="Print this book" aria-label="Print this book">
                        <i id="print-button" class="fa fa-print"></i>
                    </a>
                    
                    <a href="https://github.com/lfe/tutorial/" title="Git repository" aria-label="Git repository">
                        <i id="git-repository-button" class="fa fa-github"></i>
                    </a>
                    
                </div>
            </div>

            
            <div id="search-wrapper" class="hidden">
                <form id="searchbar-outer" class="searchbar-outer">
                    <input type="search" name="search" id="searchbar" name="searchbar"
                        placeholder="Search this book ..." aria-controls="searchresults-outer"
                        aria-describedby="searchresults-header">
                </form>
                <div id="searchresults-outer" class="searchresults-outer hidden">
                    <div id="searchresults-header" class="searchresults-header"></div>
                    <ul id="searchresults">
                    </ul>
                </div>
            </div>
            

            <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
            <script type="text/javascript">
                document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                Array.from(document.querySelectorAll('#sidebar a')).forEach(function (link) {
                    link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                });
            </script>

            <div id="content" class="content">
                <main>
                    <h1><a class="header" href="#the-lfe-tutorial" id="the-lfe-tutorial">The LFE Tutorial</a></h1>
<p><a href="images/cover-large.jpg"><img src="images/cover.jpg" alt="" /></a></p>
<p><em>Adapted from the Erlang &quot;Getting Started&quot; tutorial</em></p>
<p>Original Erlang version by the Erlang/OTP Team</p>
<p>LFE translation by Robert Virding and Duncan McGreggor</p>
<!-- Named page links below: /-->
<h1><a class="header" href="#copyright" id="copyright">Copyright</a></h1>
<p>© 1996-2020, Ericsson AB</p>
<p>© 2015, 2020 Robert Virding, Duncan McGreggor</p>
<p>The contents of this file are subject to the Erlang Public License,
Version 1.1, (the &quot;License&quot;); you may not use this file except in
compliance with the License. You should have received a copy of the
Erlang Public License along with this software. If not, it can be
retrieved online at http://www.erlang.org/.</p>
<p>Software distributed under the License is distributed on an &quot;AS IS&quot;
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
the License for the specific language governing rights and limitations
under the License.</p>
<h1><a class="header" href="#introduction" id="introduction">Introduction</a></h1>
<p>In this chapter we will provide brief introdsuctions to Erlang, OTP, and LFE as well as discussion the dependencies for LFE development, and finally obtaining and building LFE from source.</p>
<h1><a class="header" href="#about-erlang" id="about-erlang">About Erlang</a></h1>
<p>Erlang is a programming language used to build massively scalable soft real-time systems with requirements on high availability. Some of its uses are in telecoms, banking, e-commerce, computer telephony and instant messaging. Erlang's runtime system has built-in support for concurrency, distribution and fault tolerance.</p>
<p>Most real-world Erlang aapplications are built using Erlang/OTP. OTP is set of Erlang libraries and design principles providing middleware to develop these systems. It includes its own distributed database, applications to interface towards other languages, debugging and release handling tools.</p>
<p>As an LFE programmer, you will have the adbility and freedom to utilize Erlang and OTP libraries directly from a Lisp syntax.</p>
<h1><a class="header" href="#about-lfe" id="about-lfe">About LFE</a></h1>
<p>LFE, or &quot;Lisp Flavoured Erlang&quot;, is a Lisp-2 (thus similar to Common Lisp, and
MACLISP before that) that runs on top of the Erlang VM or &quot;BEAM&quot;. It is the
oldest sibling of the many BEAM languages that have been released since its
inception (e.g., Elixir, Joxa, Luerl, Erlog, Haskerl, Clojerl, Hamler, etc.).</p>
<p>As a Lisp-2, LFE has different namespaces for functions and variables.
Furthermore, LFE has Erlang's notion of arity, so functions with different
arity may share the same name.</p>
<p>Lisps are great, but the thing that makes LFE so incredible is that it runs
on the Erlang VM and is 100% compatible with Core Erlang.</p>
<h1><a class="header" href="#dependencies" id="dependencies">Dependencies</a></h1>
<p>In order to write LFE scripts, libraries, and applications, you will need to install the following:</p>
<ul>
<li>Erlang</li>
<li><code>make</code> and related developer tools</li>
<li><code>git</code></li>
</ul>
<h2><a class="header" href="#installing-erlang" id="installing-erlang">Installing Erlang</a></h2>
<p>First and foremost, you will need Erlang installed.</p>
<ul>
<li>On Mac OS X, this is as easy as executing <code>brew install erlang</code></li>
<li>On Ubuntu <code>apt-get install erlang</code>.</li>
</ul>
<p>You can also install Erlang from the various pre-built packages
provided on the <a href="http://www.erlang.org/download.html">official Erlang
download page</a> or from the
<a href="https://www.erlang-solutions.com/downloads/download-erlang-otp">Erlang
Solutions page</a> (which supports many more package types).</p>
<p>For those who have the need of installing multiple versions of Erlang, there is also the <a href="https://github.com/spawngrid/kerl">kerl</a> project.</p>
<h2><a class="header" href="#installing-make" id="installing-make">Installing <code>make</code></a></h2>
<p>In order to use LFE, you will be calling <code>make</code> to compile it. To cover your bases, you'll want to make sure you have the basic development tools installed for your platform.</p>
<p>Ubuntu:</p>
<pre><code class="language-bash">sudo apt-get install build-essential
</code></pre>
<p>CentOS/Fedora:</p>
<pre><code class="language-bash">sudo yum groupinstall &quot;Development Tools&quot;
</code></pre>
<p>For Mac OS X, you will need to install the &quot;Developer Tools&quot; from the AppStore.</p>
<h2><a class="header" href="#installing-git" id="installing-git">Installing <code>git</code></a></h2>
<p>You will also need <code>git</code> to continue with this quick-start. If <code>git</code> doesn't come installed on your system and it wansn't installed as part of your systems basic development tools package, you can <a href="http://git-scm.com/downloads">download it here</a>
or install it using your favourite OS package manager.</p>
<h1><a class="header" href="#installing-lfe" id="installing-lfe">Installing LFE</a></h1>
<h2><a class="header" href="#downloading-the-source" id="downloading-the-source">Downloading the Source</a></h2>
<p>The most recent version of LFE is always available here:</p>
<ul>
<li>https://github.com/rvirding/lfe/</li>
</ul>
<p>With <code>git</code> in your <code>PATH</code>, you can download LFE:</p>
<pre><code class="language-bash">git clone https://github.com/rvirding/lfe.git
cd lfe
</code></pre>
<p>You have two choices for the type of LFE build you want to do.</p>
<p>Now everything is ready to go!</p>
<div class="alert alert-success">
  <h4 class="alert-heading">
    <i class="fa fa-info-circle" aria-hidden="true"></i>
    Stable
  </h4>
  <p class="mb-0">
    Stable contains a version of LFE that is known to be fully reliable and used in production for years.
  </p>
</div>
<p>To build the latest stable release, make sure you are on the <code>master</code> branch:</p>
<pre><code class="language-bash">git checkout master
</code></pre>
<div class="alert alert-warning">
  <h4 class="alert-heading">
    <i class="fa fa-exclamation-triangle" aria-hidden="true"></i>
Unstable
  </h4>
  <p class="mb-0">
    Unstable contains LFE that is under active development, has not been released, or has not had extensive use and testing in production environments.
  </p>
</div>
<p>To build the latest unstable LFE, make sure you are on the <code>develop</code> branch:</p>
<pre><code class="language-bash">git checkout develop
</code></pre>
<p>LFE is just a set of Erlang libraries, so like an Erlang project, the source code needs to be compiled to <code>.beam</code> files. Running <code>make</code> in the <code>lfe</code> directory will do that:</p>
<pre><code class="language-bash">make
</code></pre>
<h1><a class="header" href="#sequential-programming" id="sequential-programming">Sequential Programming</a></h1>
<p>In this chapter we will look at the basics of sequential programming in LFE.</p>
<h2><a class="header" href="#the-lfe-repl" id="the-lfe-repl">The LFE REPL</a></h2>
<p>Most operating systems have a command interpreter or shell -- Unix and Linux have many, while Windows has the Command Prompt. Likewise, Erlang has a shell where you can directly write bits of Erlang code and evaluate (run) them to see what happens. LFE has more than a shell: it's a full REPL (<em>read-eval-print loop</em>) like other Lisps, and it can do more than the Erlang shell can (including defining proper functions and Lisp macros).</p>
<h3><a class="header" href="#starting-the-lfe-repl" id="starting-the-lfe-repl">Starting the LFE REPL</a></h3>
<p>In your system terminal window where you changed directory to the clone of the LFE repository, you can start the LFE REPL by typing the following:</p>
<pre><code class="language-bash">./bin/lfe
</code></pre>
<p>At which point you will see output something like this:</p>
<pre><code>Erlang/OTP 23 [erts-11.0.2] [source] [64-bit] [smp:12:12] [ds:12:12:10] [async-threads:1] [hipe] [dtrace]

   ..-~.~_~---..
  (      \\     )    |   A Lisp-2+ on the Erlang VM
  |`-.._/_\\_.-':    |   Type (help) for usage info.
  |         g |_ \   |
  |        n    | |  |   Docs: http://docs.lfe.io/
  |       a    / /   |   Source: http://github.com/rvirding/lfe
   \     l    |_/    |
    \   r     /      |   LFE v1.3-dev (abort with ^G)
     `-E___.-'

lfe&gt;
</code></pre>
<h3><a class="header" href="#interactive-lfe-code" id="interactive-lfe-code">Interactive LFE Code</a></h3>
<p>Now let's multiply two numbers in the REPL by typing <code>(* 2 21)</code> at the <code>&gt; </code> prompt:</p>
<pre><code class="language-lisp">lfe&gt; (* 2 21)
</code></pre>
<p>Lisp stands for &quot;LISt Processor&quot; because nearly everything in Lisp is reall just a list of things -- including the code itself. The lists in Lisps are created with parentheses, just like the expression above. As you can see, the multiplication operator goes first, followed by its arguments -- this is called <em>prefix notation</em>, due to the operator coming first.</p>
<p>In order to tell the REPL that you want it to evaluate your LFE code, you need to his the <code>&lt;ENTER&gt;</code> or <code>&lt;RETURN&gt;</code> key.</p>
<pre><code class="language-lisp">42
lfe&gt;
</code></pre>
<p>It has correctly given you the answer: 42.</p>
<p>Now let's try a more complex calculation:</p>
<pre><code class="language-lisp">lfe&gt; (* 2 (+ 1 2 3 4 5 6))
</code></pre>
<p>This expression has one nested inside the other. The first one to be executed is the inner-most, in this case, the addition operation. Just like we saw before, the operator comes first (the &quot;addition&quot; operator, in this case) and then all of the numbers to be added.</p>
<p>Hit <code>&lt;ENTER&gt;</code> to get your answer:</p>
<pre><code class="language-lisp">42
lfe&gt;
</code></pre>
<h3><a class="header" href="#defining-variables-and-functions" id="defining-variables-and-functions">Defining Variables and Functions</a></h3>
<p>The LFE REPL allows you do set variables and define functions. Let's define a variable called <code>multiplier</code>:</p>
<pre><code class="language-lisp">lfe&gt; (set multiplier 2)
2
lfe&gt;
</code></pre>
<p>When we set the value for that variable, the REPL provided feedback on the expression entered, showing us the value. Now we can use it just like the number for which it stands:</p>
<pre><code class="language-lisp">lfe&gt; (* multiplier (+ 1 2 3 4 5 6))
42
lfe&gt;
</code></pre>
<p>The <code>set</code> form lets you define a variable; the <code>defun</code> form lets you define a function. Enter this in the REPL:</p>
<pre><code class="language-lisp">lfe&gt; (defun double (x)
    (* 2 x))
</code></pre>
<p>Now try it:</p>
<pre><code class="language-lisp">lfe&gt; (double 21)
42
lfe&gt;
</code></pre>
<p>As we can see, this function multiplies any given number by <code>2</code>.</p>
<h3><a class="header" href="#leaving-the-repl" id="leaving-the-repl">Leaving the REPL</a></h3>
<p>To exit the REPL and shutdown the underlying Erlang system which started when you executed <code>./bin/lfe</code>, simply exit:</p>
<pre><code class="language-lisp">lfe&gt; (exit)
ok
</code></pre>
<p>At which point you will be presented with your regular system terminal prompt.</p>
<p>There are two other ways in which you may leave the REPL:</p>
<ul>
<li>Hitting <code>^c</code> twice in a row, or</li>
<li>Hitting <code>^g</code> then <code>q</code></li>
</ul>
<h2><a class="header" href="#modules-and-functions" id="modules-and-functions">Modules and Functions</a></h2>
<h3><a class="header" href="#creating-a-simple-module" id="creating-a-simple-module">Creating a Simple Module</a></h3>
<p>A programming language isn't much use if you can only run code from a REPL. So next we will write a small LFE program in a file on the file system. In the same directory that you started the LFE REPL, create a new file called <code>tut1.lfe</code> (the filename is <strong>important</strong>: be sure you type it just as we have) using your favorite text editor.</p>
<p>Here's the code to enter:</p>
<pre><code class="language-lisp">(defmodule tut1
  (export all))

(defun double (x)
  (* 2 x))
</code></pre>
<p>It's not hard to guess that this &quot;program&quot; doubles the value of numbers. We'll get back to the first two lines later. Let's compile the program. This can be done in the LFE REPL as shown below:</p>
<pre><code class="language-lisp">lfe&gt; (c &quot;tut1.lfe&quot;)
#(module tut1)
lfe&gt;
</code></pre>
<p>The <code>#(module tut1)</code> tells you that the compilation was successful. If it said &quot;error&quot; instead, you have made some mistake in the text you entered and there will also be error messages to give you some idea as to what has gone wrong so you can change what you have written and try again.</p>
<p>Now lets run the program.</p>
<pre><code class="language-lisp">lfe&gt; (tut1:double 108)
216
lfe&gt;
</code></pre>
<p>As expected, <code>108</code> doubled is 216.</p>
<p>Now let's get back to the first two lines. LFE programs are written in files. Each file contains what we call an <em>LFE module</em>. The first line of code in the module tells LFE that we're defining a module and giving it a name:</p>
<pre><code class="language-lisp">(defmodule tut1
</code></pre>
<p>The name of our module is <code>tut1</code> and the file which is used to store the module must have the same name as the module but with the <code>.lfe</code> extension. In our case the file name is <code>tut1.lfe</code>.</p>
<p>In LFE, whenever we use a function that has been defined in another module, we use the syntax, <code>(module:function argument1 argument2 ...)</code>. So</p>
<pre><code class="language-lisp">lfe&gt; (tut1:double 108)
</code></pre>
<p>means &quot;call the function <code>double</code> in the module <code>tut1</code> with the argument of <code>108</code>.</p>
<p>The second line tells LFE which functions we will be exporting -- in this case, all of them (which is only <em>one</em> ...):</p>
<pre><code class="language-lisp">  (export all))
</code></pre>
<p>If we wanted to be explicit about which functions were to be exported, we would have written:</p>
<pre><code class="language-lisp">(defmodule tut1
  (export (double 1)))
</code></pre>
<p>That says &quot;in the module <code>tut1</code>, please make available the function called <code>double</code> which takes one argument&quot; (<code>x</code> in our example). By &quot;make available&quot; we mean that this function can be called from outside the module <code>tut1</code>.</p>
<h3><a class="header" href="#a-more-complicated-example" id="a-more-complicated-example">A More Complicated Example</a></h3>
<p>Now for a more complicated example, the factorial of a number (e.g. factorial of 4 is 4 * 3 * 2 * 1). Enter the following code in a file called <code>tut2.lfe</code>.</p>
<pre><code class="language-lisp">(defmodule tut2
  (export (fac 1)))

(defun fac
  ((1) 1)
  ((n) (* n (fac (- n 1)))))
</code></pre>
<p>Compile the file</p>
<pre><code class="language-lisp">lfe&gt; (c &quot;tut2.lfe&quot;)
#(module tut2)
</code></pre>
<p>And now calculate the factorial of 4.</p>
<pre><code class="language-lisp">lfe&gt; (tut2:fac 4)
24
</code></pre>
<p>The function <code>fac</code> contains two parts. The first part:</p>
<pre><code class="language-lisp">  ((1) 1)
</code></pre>
<p>says that the factorial of 1 is 1. Note that this part is a separate list in the function definition where the first element is a <em>list</em> of the arguments to the function and the rest is the body of the function. The second part:</p>
<pre><code class="language-lisp">  ((n) (* n (fac (- n 1)))))
</code></pre>
<p>says that the factorial of n is n multiplied by the factorial of n - 1. After this part which is the last part we end the function definition with the closing <code>)</code>.</p>
<p>A function can have many arguments. Let's expand the module <code>tut2</code> with the rather stupid function to multiply two numbers:</p>
<pre><code class="language-lisp">(defmodule tut3
  (export (fac 1) (mult 2)))

(defun fac
  ((1) 1)
  ((n) (* n (fac (- n 1)))))

(defun mult (x y)
  (* x y))

</code></pre>
<p>Note that we have also had to expand the <code>(export</code> line with the information that there is another function <code>mult</code> with two arguments. Compile the file:</p>
<pre><code class="language-lisp">lfe&gt; (c &quot;tut3.lfe&quot;)
#(module tut3)
</code></pre>
<p>and try it out:</p>
<pre><code class="language-lisp">lfe&gt; (tut3:mult 3 4)
12
</code></pre>
<p>In the example above the numbers are integers and the arguments in the functions in the code, <code>n</code>, <code>x</code>, <code>y</code> are called variables. Examples of variables could be <code>number</code>, <code>shoe-size</code>, <code>age</code> etc.</p>
<p>Note that when a function has only one part and all the arguments are variables then we can use the shorter form we saw in <code>double</code> and <code>mult</code>. This means that we could also have written <code>mult</code> as:</p>
<pre><code class="language-lisp">(defun mult
  ((x y) (* x y)))
</code></pre>
<h2><a class="header" href="#atoms" id="atoms">Atoms</a></h2>
<p>Atoms are another data type in LFE. They are words, for example <code>charles</code>, <code>centimeter</code>, <code>inch</code> and <code>ok</code>. Atoms are similar to symbols in Lisp except that are simply names, nothing else. They are not like variables which can have a value.</p>
<p>Enter the next program (file: <code>tut4.lfe</code>) which could be useful for converting from inches to centimeters and vice versa:</p>
<pre><code class="language-lisp">(defmodule tut4
  (export (convert 2)))

(defun convert
  ((m 'inch) (/ m 2.54))
  ((n 'centimeter) (* n 2.54)))
</code></pre>
<p>Compile and test:</p>
<pre><code class="language-lisp">lfe&gt; (c &quot;tut4.lfe&quot;)
#(module tut4)
lfe&gt; (tut4:convert 3 'inch)
1.1811023622047243
lfe&gt; (tut4:convert 7 'centimeter)
17.78
</code></pre>
<p>Notice that atoms and variables look the same so we have to tell LFE when we want it to be an atom. We do this by <em>quoting</em> the atom with a <code>'</code>, for example <code>'inch</code> and <code>'centimeter</code>. We have to do this both when we use it as argument in a function definition and when we use it when calling a function, otherwise LFE will assume that it is a variable.</p>
<p>Also notice that we have introduced decimals (floating point numbers) without any explanation, but I guess you can cope with that.</p>
<p>See what happens if I enter something other than centimeter or inch in the convert function:</p>
<pre><code class="language-lisp">lfe&gt; (tut4:convert 3 'miles)
exception error: function_clause
  in (: tut4 convert 3 miles)
</code></pre>
<p>The two parts of the convert function are called its <em>clauses</em>. Here we see that <code>miles</code> is not part of either of the clauses. The LFE system can't <strong>match</strong> either of the clauses so we get an error message <code>function_clause</code>. The shell formats the error message nicely, but to see the actual error tuple we can do:</p>
<pre><code class="language-lisp">lfe&gt; (catch (tut4:convert 3 'miles))
#(EXIT
  #(function_clause
    (#(tut2 convert (3 miles) (#(file &quot;./tut2.lfe&quot;) #(line 4)))
     #(lfe_eval eval_expr 2 (#(file &quot;src/lfe_eval.erl&quot;) #(line 160)))
     #(lfe_shell eval_form_1 2 (#(file &quot;src/lfe_shell.erl&quot;) #(line 268)))
     #(lists foldl 3 (#(file &quot;lists.erl&quot;) #(line 1261)))
     #(lfe_shell server_loop 1 (#(file &quot;src/lfe_shell.erl&quot;) #(line 101))))))
</code></pre>
<h2><a class="header" href="#tuples" id="tuples">Tuples</a></h2>
<p>Now the <code>tut4</code> program is hardly good programming style. Consider:</p>
<pre><code class="language-lisp">(tut4:convert 3 'inch)
</code></pre>
<p>Does this mean that 3 is in inches? or that 3 is in centimeters and we want to convert it to inches? So LFE has a way to group things together to make things more understandable. We call these tuples. Tuples are constructed and matched using <code>(tuple ...)</code>, with literal tuples being written with <code>#( ... )</code>.</p>
<p>So we can write <code>#(inch 3)</code> to denote 3 inches and <code>#(centimeter 5)</code> to denote 5 centimeters. Now let's write a new program which converts centimeters to inches and vice versa (file <code>tut5.lfe</code>).</p>
<pre><code class="language-lisp">(defmodule tut5
  (export (convert-length 1)))

(defun convert-length
  (((tuple 'centimeter x)) (tuple 'inch (/ x 2.54)))
  (((tuple 'inch y)) (tuple 'centimeter (* y 2.54))))
</code></pre>
<p>Compile and test:</p>
<pre><code class="language-lisp">(c &quot;tut5.lfe&quot;)
#(module tut5)
lfe&gt; (tut5:convert-length #(inch 5))
#(centimeter 12.7)
lfe&gt; (tut5:convert-length (tut5:convert-length #(inch 5)))
#(inch 5.0)
</code></pre>
<p>Note that in the last call we convert 5 inches to centimeters and back again and reassuringly get back to the original value. I.e the argument to a function can be the result of another function. Pause for a moment and consider how that line (above) works. The argument we have given the function <code>#(inch 5)</code> is first matched against the first head clause of <code>convert-length</code> i.e. in <code>((tuple 'centimeter x))</code> where it can be seen that the pattern <code>(tuple 'centimeter x)</code> does not match <code>#(inch 5)</code> (the <em>head</em> is the first bit in the clause with a list of argument patterns). This having failed, we try the head of the next clause i.e. <code>((tuple 'inch y))</code>, this pattern matches <code>#(inch 5)</code> and <code>y</code> gets the value 5.</p>
<p>We have shown tuples with two parts above, but tuples can have as many parts as we want and contain any valid LFE <strong>term</strong>. For example, to represent the temperature of various cities of the world we could write</p>
<pre><code class="language-lisp">#(Moscow #(C -10))
#(Cape-Town #(F 70))
#(Paris #(F 28))
</code></pre>
<p>Tuples have a fixed number of things in them. We call each thing in a tuple an <em>element</em>. So in the tuple <code>#(Moscow #(C -10))</code>, element 1 is <code>Moscow</code> and element 2 is <code>#(C -10)</code>. We have chosen <code>C</code> meaning Celsius (or Centigrade) and <code>F</code> meaning Fahrenheit.</p>
<h2><a class="header" href="#lists" id="lists">Lists</a></h2>
<p>Whereas tuples group things together, we also want to be able to represent lists of things. Lists in LFE are surrounded by &quot;(&quot; and &quot;)&quot;. For example a list of the temperatures of various cities in the world could be:</p>
<pre><code class="language-lisp">(#(Moscow #(C -10))
 #(Cape-Town #(F 70)) #(Stockholm #(C -4))
 #(Paris #(F 28)) #(London #(F 36)))
</code></pre>
<p>Note that this list was so long that it didn't fit on one line. This doesn't matter, LFE allows line breaks at all &quot;sensible places&quot; but not, for example, in the middle of atoms, integers etc.</p>
<p>A very useful way of looking at parts of lists is by using the constructor <code>cons</code>. It can also be used as a pattern to match against lists. This is best explained by an example using the shell.</p>
<pre><code class="language-lisp">lfe&gt; (set (cons first rest) '(1 2 3 4 5))
(1 2 3 4 5)
lfe&gt; first
1
lfe&gt; rest
(2 3 4 5)
</code></pre>
<p>We see here that <code>set</code> also allows you to define variables using patterns. Using <code>cons</code> we could separate the first element of the list from the rest of list (<code>first</code> got the value 1 and <code>rest</code> the value (2 3 4 5)). We also see here that when we want to give a literal list we need to <em>quote</em> it with <code>'</code>. This stops LFE trying to evaluate the list as a function call in the same way as quoting an atom stops LFE trying to evaluate the atom as a variable.</p>
<p>Another example:</p>
<pre><code class="language-lisp">lfe&gt; (set (cons e1 (cons e2 r)) '(1 2 3 4 5 6 7))
(1 2 3 4 5 6 7)
lfe&gt; e1
1
lfe&gt; e2
2
lfe&gt; r
(3 4 5 6 7)
</code></pre>
<p>We see here nesting <code>cons</code> to get the first two elements from the list. Of course if we try to get more elements from the list than there are elements in the list we will get an error. Note also the special case of the list with no elements ().</p>
<pre><code class="language-lisp">lfe&gt; (set (cons a (cons b c)) '(1 2))
(1 2)
lfe&gt; a
1
lfe&gt; b
2
lfe&gt; c
()
</code></pre>
<p>In all examples above we have been using new variables names, not reusing old ones. While <code>set</code> does allow you to rebind variables normally a variable can only be given a value once in its context (scope).</p>
<p>The following example shows how we find the length of a list:</p>
<pre><code class="language-lisp">(defmodule tut6
  (export (list-length 1)))

(defun list-length
  ((()) 0)
  (((cons first rest))
   (+ 1 (list-length rest))))
</code></pre>
<p>Compile (file <code>tut4.lfe</code>) and test:</p>
<pre><code class="language-lisp">lfe&gt; (c &quot;tut6.lfe&quot;)
#(module tut6)
lfe&gt; (tut6:list-length '(1 2 3 4 5 6 7))
7
</code></pre>
<p>Explanation:</p>
<pre><code class="language-lisp">(defun list-length
  ((()) 0)
</code></pre>
<p>The length of an empty list is obviously 0.</p>
<pre><code class="language-lisp">  (((cons first rest))
   (+ 1 (list-length rest))))
</code></pre>
<p>The length of a list with the first element <code>first</code> and the remaining elements <code>rest</code> is 1 + the length of <code>rest</code>.</p>
<p>(Advanced readers only: This is not tail recursive, there is a better way to write this function).</p>
<p>In general we can say we use tuples where we would use &quot;records&quot; or &quot;structs&quot; in other languages and we use lists when we want to represent things which have varying sizes, (i.e. where we would use linked lists in other languages).</p>
<p>LFE does not have a string data type, instead strings can be represented by lists of Unicode characters. So the list <code>(97 98 99)</code> is equivalent to &quot;abc&quot;. Note that we don't have to quote strings as we do lists. The LFE repl is &quot;clever&quot; and guesses the what sort of list we mean and outputs it in what it thinks is the most appropriate form, for example:</p>
<pre><code class="language-lisp">lfe&gt; '(97 98 99)
&quot;abc&quot;
lfe&gt; &quot;abc&quot;
&quot;abc&quot;
lfe&gt; '&quot;abc&quot;
&quot;abc&quot;
</code></pre>
<p>Lists can also be surrounded by &quot;[&quot; and &quot;]&quot; instead of parentheses. They are equivalent but must match, for example:</p>
<pre><code class="language-lisp">lfe&gt; '(a b c)
(a b c)
lfe&gt; '[a b c]
(a b c)
lfe&gt; '(a b c]
1: illegal ']'
</code></pre>
<p>This can be used to make list structures easier to read. For example, it is often used in function definitions for the list of arguments when there are multiple clauses:</p>
<pre><code class="language-lisp">(defun list-length
  ([()] 0)
  ([(cons first rest)]
   (+ 1 (list-length rest))))
</code></pre>
<h2><a class="header" href="#property-lists-and-maps" id="property-lists-and-maps">Property Lists and Maps</a></h2>
<h3><a class="header" href="#property-lists" id="property-lists">Property Lists</a></h3>
<p>Property lists in Erlang and LFE are a simple way to create key-value pairs (we actually saw them in the last section, but didn't mention it). They have a very simple structure: a list of tuples, where the key is the first element of each tuple and is an atom. Very often you will see &quot;options&quot; for functions provided as property lists (this is similar to how other programming languages use keywords in function arguments).</p>
<p>Property lists can be created with just the basic data structures of LFE:</p>
<pre><code class="language-lisp">lfe&gt; (set options (list (tuple 'debug 'true)
                     (tuple 'default 42)))
(#(debug true) #(default 42))
</code></pre>
<p>Or, more commonly, using quoted literals:</p>
<pre><code class="language-lisp">lfe&gt; (set options '(#(debug true) #(default 42)))
(#(debug true) #(default 42))
</code></pre>
<p>There are convenience functions provided in the <code>proplists</code> module. In the last example, we define a default value to be used in the event that the given key is not found in the proplist:</p>
<pre><code class="language-lisp">lfe&gt; (proplists:get_value 'default options)
42
lfe&gt; (proplists:get_value 'poetry options)
undefined
lfe&gt; (proplists:get_value 'poetry options &quot;Vogon&quot;)
&quot;Vogon&quot;
</code></pre>
<p>Be sure to read the <a href="http://www.erlang.org/doc/man/proplists.html">module documentation</a> for more information. Here's an example of our options in action:</p>
<pre><code class="language-lisp">(defun div (a b)
  (div a b '()))

(defun div (a b opts)
  (let ((debug (proplists:get_value 'debug opts 'false))
        (ratio? (proplists:get_value 'ratio opts 'false)))
    (if (and debug ratio?)
        (io:format &quot;Returning as ratio ...~n&quot;))
    (if ratio?
        (++ (integer_to_list 1) &quot;/&quot; (integer_to_list 2))
        (/ a b))))
</code></pre>
<p>Let's try our funtion without and then with various options:</p>
<pre><code class="language-lisp">lfe&gt; (div 1 2)
0.5
lfe&gt; (div 1 2 '(#(ratio true)))
&quot;1/2&quot;
lfe&gt; (div 1 2 '(#(ratio true) #(debug true)))
Returning as ratio ...
&quot;1/2&quot;
</code></pre>
<h3><a class="header" href="#maps" id="maps">Maps</a></h3>
<p>As with property lists, maps are a set of key to value associations. You may create an association from &quot;key&quot; to value 42 in one of two ways: using the LFE core form <code>map</code> or entering a map literal:</p>
<pre><code class="language-lisp">lfe&gt; (map &quot;key&quot; 42)
#M(&quot;key&quot; 42)
lfe&gt; #M(&quot;key&quot; 42)
#M(&quot;key&quot; 42)
</code></pre>
<p>We will jump straight into the deep end with an example using some interesting features. The following example shows how we calculate alpha blending using maps to reference color and alpha channels. Save this code as the file <code>color.lfe</code> in the directory from which you have run the LFE REPL:</p>
<pre><code class="language-lisp">(defmodule tut7
  (export (new 4) (blend 2)))

(defmacro channel? (val)
  `(andalso (is_float ,val) (&gt;= ,val 0.0) (=&lt; ,val 1.0)))

(defmacro all-channels? (r g b a)
  `(andalso (channel? ,r)
            (channel? ,g)
            (channel? ,b)
            (channel? ,a)))

(defun new
  ((r g b a) (when (all-channels? r g b a))
   (map 'red r 'green g 'blue b 'alpha a)))

(defun blend (src dst)
  (blend src dst (alpha src dst)))

(defun blend
  ((src dst alpha) (when (&gt; alpha 0.0))
   (map-update dst
               'red (/ (red src dst) alpha)
               'green (/ (green src dst) alpha)
               'blue (/ (blue src dst) alpha)
               'alpha alpha))
  ((_ dst _)
   (map-update dst 'red 0 'green 0 'blue 0 'alpha 0)))

(defun alpha
  (((map 'alpha src-alpha) (map 'alpha dst-alpha))
   (+ src-alpha (* dst-alpha (- 1.0 src-alpha)))))

(defun red
  (((map 'red src-val 'alpha src-alpha)
    (map 'red dst-val 'alpha dst-alpha))
   (+ (* src-val src-alpha)
      (* dst-val dst-alpha (- 1.0 src-alpha)))))

(defun green
  (((map 'green src-val 'alpha src-alpha)
    (map 'green dst-val 'alpha dst-alpha))
   (+ (* src-val src-alpha)
      (* dst-val dst-alpha (- 1.0 src-alpha)))))

(defun blue
  (((map 'blue src-val 'alpha src-alpha)
    (map 'blue dst-val 'alpha dst-alpha))
   (+ (* src-val src-alpha)
      (* dst-val dst-alpha (- 1.0 src-alpha)))))
</code></pre>
<p>Now let's try it out, first compiling it:</p>
<pre><code class="language-lisp">lfe&gt; (c &quot;tut7.lfe&quot;)
#(module tut7)
lfe&gt; (set color-1 (tut7:new 0.3 0.4 0.5 1.0))
#M(alpha 1.0 blue 0.5 green 0.4 red 0.3)
lfe&gt; (set color-2 (tut7:new 1.0 0.8 0.1 0.3))
#M(alpha 0.3 blue 0.1 green 0.8 red 1.0)
lfe&gt; (tut7:blend color-1 color-2)
#M(alpha 1.0 blue 0.5 green 0.4 red 0.3)
lfe&gt; (tut7:blend color-2 color-1)
#M(alpha 1.0 blue 0.38 green 0.52 red 0.51)
</code></pre>
<p>This example warrants some explanation.</p>
<p>First we define a couple macros to help with our guard tests. This is only here for convenience and to reduce syntax cluttering. Guards can be only composed of a limited set of functions, so we needed to use macros that would compile down to just the funtions allowed in guards. A full treatment of Lisp macros is beyond the scope of this tutorial, but there is a lot of good material available online for learning macros, including Paul Graham's book &quot;On Lisp.&quot;</p>
<pre><code class="language-lisp">(defun new
  ((r g b a) (when (all-channels? r g b a))
   (map 'red r 'green g 'blue b 'alpha a)))
</code></pre>
<p>The function <code>new/4</code> <sup class="footnote-reference"><a href="#1">1</a></sup> creates a new map term with and lets the keys <code>red</code>, <code>green</code>, <code>blue</code> and <code>alpha</code> be associated with an initial value. In this case we only allow for float values between and including 0.0 and 1.0 as ensured by the <code>all-channels?</code> and <code>channel?</code> macros.</p>
<p>By calling <code>blend/2</code> on any color term created by <code>new/4</code> we can calculate the resulting color as determined by the two maps terms.</p>
<p>The first thing <code>blend/2</code> does is to calculate the resulting alpha channel.</p>
<pre><code class="language-lisp">(defun alpha
  (((map 'alpha src-alpha) (map 'alpha dst-alpha))
   (+ src-alpha (* dst-alpha (- 1.0 src-alpha)))))
</code></pre>
<p>We fetch the value associated with key <code>alpha</code> for both arguments using the <code>(map 'alpha &lt;var&gt;)</code> pattern. Any other keys in the map are ignored, only the key <code>alpha</code> is required and checked for.</p>
<p>This is also the case for functions <code>red/2</code>, <code>blue/2</code> and <code>green/2</code>.</p>
<pre><code class="language-lisp">(defun red
  (((map 'red src-val 'alpha src-alpha)
    (map 'red dst-val 'alpha dst-alpha))
   (+ (* src-val src-alpha)
      (* dst-val dst-alpha (- 1.0 src-alpha)))))
</code></pre>
<p>The difference here is that we check for two keys in each map argument. The other keys are ignored.</p>
<p>Finally we return the resulting color in <code>blend/3</code>.</p>
<pre><code class="language-lisp">(defun blend
  ((src dst alpha) (when (&gt; alpha 0.0))
   (map-update dst
               'red (/ (red src dst) alpha)
               'green (/ (green src dst) alpha)
               'blue (/ (blue src dst) alpha)
               'alpha alpha))
</code></pre>
<p>We update the <code>dst</code> map with new channel values. The syntax for updating an existing key with a new value is done with <code>map-update</code> form.</p>
<hr />
<p><sup class="footnote-reference"><a href="#1">1</a></sup> Note the use of the slash and number after the function name. We will be discussing this more in a future section, though before we get there you will see this again. Until we get to the full explanation, just know that the number represents the arity of a given function and this helps us be explicit about which function we mean.</p>
<h2><a class="header" href="#the-erlang-standard-library" id="the-erlang-standard-library">The Erlang Standard Library</a></h2>
<h3><a class="header" href="#man-pages-and-online-docs" id="man-pages-and-online-docs"><code>man</code> Pages and Online Docs</a></h3>
<p>Erlang has a lot of standard modules to help you do things which are directly callable from LFE. For example, the module <code>io</code> contains a lot of functions to help you perform various acts of formatted input/output. Depending upon your Erlang installation, you may have man pages available. From your operating system shell, you can found out by typing <code>erl -man &lt;module name&gt;</code> like so:</p>
<pre><code class="language-bash">erl -man io
</code></pre>
<p>If you have man pages installed, that command would give output along these lines:</p>
<pre><code>ERLANG MODULE DEFINITION                                    io(3)

MODULE
     io - Standard I/O Server Interface Functions

DESCRIPTION
     This module provides an  interface  to  standard  Erlang  IO
     servers. The output functions all return ok if they are suc-
     ...
</code></pre>
<p>If your installation of Erlang doesn't have man pages, you can always find what you're looking for on the documentation web site. Here is the online manpage for the <a href="http://erlang.org/doc/man/io.html">io module</a>.</p>
<h3><a class="header" href="#module-and-function-tab-completion-in-the-repl" id="module-and-function-tab-completion-in-the-repl">Module and Function Tab-Completion in the REPL</a></h3>
<p>From the LFE REPL, you have some other nice options for standard library discovery. Start up LFE to take a look:</p>
<pre><code>./bin/lfe
Erlang/OTP 23 [erts-11.0.2] [source] [64-bit] [smp:12:12] ...

lfe&gt;
</code></pre>
<p>Now, at the prompt, hit your <code>&lt;TAB&gt;</code> key. You should see something like this:</p>
<pre><code>application               application_controller    application_master
beam_lib                  binary                    c
code                      code_server               edlin
edlin_expand              epp                       erl_distribution
erl_eval                  erl_parse                 erl_prim_loader
erl_scan                  erlang                    error_handler
error_logger              error_logger_tty_h        erts_internal
ets                       file                      file_io_server
file_server               filename                  gb_sets
gb_trees                  gen                       gen_event
gen_server                global                    global_group
group                     heart                     hipe_unified_loader
inet                      inet_config               inet_db
inet_parse                inet_udp                  init
io                        io_lib                    io_lib_format
kernel                    kernel_config             lfe_env
lfe_eval                  lfe_init                  lfe_io
lfe_shell                 lists                     net_kernel
orddict                   os                        otp_ring0
prim_eval                 prim_file                 prim_inet
prim_zip                  proc_lib                  proplists
ram_file                  rpc                       standard_error
supervisor                supervisor_bridge         sys
unicode                   user_drv                  user_sup
zlib
</code></pre>
<p>These are all the modules available to you by default in the LFE REPL. Now type <code>(g</code> and hit <code>&lt;TAB&gt;</code>:</p>
<pre><code class="language-lisp">lfe&gt; (g
</code></pre>
<pre><code>gb_sets         gb_trees        gen             gen_event
gen_server      global          global_group    group
</code></pre>
<p>Let's keep going! Continue typing a full module, and then hit <code>&lt;TAB&gt;</code> again:</p>
<pre><code class="language-lisp">lfe&gt; (gb_trees:
</code></pre>
<pre><code>add/2            add_element/2    balance/1        del_element/2
delete/2         delete_any/2     difference/2     empty/0
filter/2         fold/3           from_list/1      from_ordset/1
insert/2         intersection/1   intersection/2   is_disjoint/2
is_element/2     is_empty/1       is_member/2      is_set/1
is_subset/2      iterator/1       largest/1        module_info/0
module_info/1    new/0            next/1           singleton/1
size/1           smallest/1       subtract/2       take_largest/1
take_smallest/1  to_list/1        union/1          union/2
</code></pre>
<p>Now you can see all the <em>functions</em> that are available in the module you have selected. This is a great feature, allowing for easy use as well as exploration and discovery.</p>
<h2><a class="header" href="#writing-output-to-a-terminal" id="writing-output-to-a-terminal">Writing Output to a Terminal</a></h2>
<p>It's nice to be able to do formatted output in these example, so the next example shows a simple way to use to use the <code>lfe_io:format</code> function. Of course, just like all other exported functions, you can test the <code>lfe_io:format</code> function in the repl:</p>
<pre><code class="language-lisp">lfe&gt; (lfe_io:format &quot;hello world~n&quot; ())
hello world
ok
lfe&gt; (lfe_io:format &quot;this outputs one LFE term: ~w~n&quot; '(hello))
this outputs one LFE term: hello
ok
lfe&gt; (lfe_io:format &quot;this outputs two LFE terms: ~w~w~n&quot; '(hello world))
this outputs two LFE terms: helloworld
ok
lfe&gt; (lfe_io:format &quot;this outputs two LFE terms: ~w ~w~n&quot; '(hello world))
this outputs two LFE terms: hello world
ok
</code></pre>
<p>The function <code>format/2</code> (i.e. <code>format</code> with two arguments) takes two lists. The first one is nearly always a list written as a string between &quot; &quot;. This list is printed out as it stands, except that each ~w is replaced by a term taken in order from the second list. Each ~n is replaced by a new line. The <code>lfe_io:format/2</code> function itself returns the atom <code>ok</code> if everything goes as planned. Like other functions in LFE, it crashes if an error occurs. This is not a fault in LFE, it is a deliberate policy. LFE has sophisticated mechanisms to handle errors which we will show later. As an exercise, try to make <code>lfe_io:format</code> crash, it shouldn't be difficult. But notice that although <code>lfe_io:format</code> crashes, the Erlang shell itself does not crash.</p>
<pre><code class="language-lisp">lfe&gt; (lfe_io:format &quot;this outputs one LFE term: ~w~n&quot; 'hello)
exception error: badarg
  in (: lfe_io fwrite1 &quot;this outputs one LFE term: ~w~n&quot; hello)
  in (lfe_io format 3)
</code></pre>
<h2><a class="header" href="#example-converting-temperature" id="example-converting-temperature">Example: Converting Temperature</a></h2>
<p>Now for a larger example to consolidate what we have learnt so far. Assume we have a list of temperature readings from a number of cities in the world. Some of them are in Celsius (Centigrade) and some in Fahrenheit (as in the previous list). First let's convert them all to Celsius, then let's print out the data neatly. Save the following code to <code>temp-convert.lfe</code>:</p>
<pre><code class="language-lisp">(defmodule tut8
  (export (format-temps 1)))

;; Only this function is exported
(defun format-temps
  ((())
    ;; No output for an empty list
    'ok)
  (((cons city rest))
    (print-temp (f-&gt;c city))
    (format-temps rest)))

(defun f-&gt;c
  (((tuple name (tuple 'C temp)))
    ;; No conversion needed
    (tuple name (tuple 'C temp)))
  (((tuple name (tuple 'F temp)))
    ;; Do the conversion
    (tuple name (tuple 'C (/ (* (- temp 32) 5) 9)))))

(defun print-temp
  (((tuple name (tuple 'C temp)))
    (lfe_io:format &quot;~-15w ~w C~n&quot; (list name temp))))
</code></pre>
<pre><code class="language-lisp">lfe&gt; (c &quot;tut8.lfe&quot;)
#(module tut8)
lfe&gt; (tut8:format-temps
    '(#(Moscow #(C 10))
      #(Cape-Town #(F 70))
      #(Stockholm #(C -4))
      #(Paris #(F 28))
      #(London #(F 36)))))
Moscow          10 C
Cape-Town       21.11111111111111 C
Stockholm       -4 C
Paris           -2.2222222222222223 C
London          2.2222222222222223 C
ok
</code></pre>
<p>Before we look at how this program works, notice that we have added a few comments to the code. A comment starts with a <code>;</code> character and goes on to the end of the line. <sup class="footnote-reference"><a href="#1">1</a></sup> Note as well that the <code>(export (format-temps 1))</code> line only includes the function <code>format-temps/1</code>, the other functions are local functions, i.e. they are not visible from outside the module <code>temp-convert</code>.</p>
<p>When we call <code>format-temps/1</code> the first time, the <code>city</code> variable gets the value <code>#(Moscow #(C-10))</code> and the remainder of the list is assigned to the <code>rest</code> variable. Next, the <code>f-&gt;c/1</code> function is called inside the <code>print-temp/1</code> function, with <code>f-&gt;c/1</code> getting passed <code>#(Moscow #(C-10))</code>.</p>
<p>Note that when we see function calls nested like <code>(print-temp (f-&gt;c ...))</code> -- in other words when one function call is passed as the argument to another function -- we execute (evaluate) them from the inside out. We first evaluate <code>(f-&gt;c city)</code> which gives the value <code>#(Moscow #(C 10))</code> as the temperature is already in Celsius and then we evaluate <code>(print-temp #(Moscow #(C 10)))</code>. Note that the <code>f-&gt;c/1</code> function  works in a similar way to the <code>convert-length/1</code> function we wrote in a previous section.</p>
<p>Next, <code>print-temp/1</code> simply calls <code>lfe_io:format/2</code> in a similar way to what has been described above. Note that <code>~-15w</code> says to print the &quot;term&quot; with a field length (width) of 15 and left justify it.<sup class="footnote-reference"><a href="#2">2</a></sup></p>
<p>Now we call <code>(format-temps rest)</code> with the remainder of the list as an argument. This way of doing things is similar to the loop constructs in other languages. (Yes, this is recursion, but don't let that worry you). So the same <code>format-temps/1</code> function is called again, this time <code>city</code> gets the value <code>#(Cape-Town #(F 70))</code> and we repeat the same procedure as before. We go on doing this until the list becomes empty, i.e. <code>()</code>, which causes the first clause <code>(format-temps '())</code> to match. This simply &quot;returns&quot; or &quot;results in&quot; the atom <code>ok</code>, so the program ends.</p>
<hr />
<p><sup class="footnote-reference"><a href="#1">1</a></sup> In LFE, the convention is that a comment starting with a single <code>;</code> is reserved for comments at the end of a line of code; lines which start with a comment use two <code>;;</code>, as above. There are also conventions for <code>;;;</code> and <code>;;;;</code> -- to learn more about these, see <a href="http://docs.lfe.io/prog-rules/1.html">Program Development Using LFE - Rules and Conventions</a> and <a href="http://docs.lfe.io/style-guide/1.html">LFE Style Guide</a>.</p>
<p><sup class="footnote-reference"><a href="#2">2</a></sup> LFE's <code>lfe_io:format</code> differs from the Erlang standard library <code>io:format</code> in that <code>lfe_io</code> displays its results using LFE-formatted data structures in its Lisp syntax; <code>io</code> uses the standard Erlang syntax. You may use either from LFE. <code>lfe_io</code> takes the same formatting parameters as <code>io</code>, so there should be no surprises if you're coming from Erlang. For more information, be sure to read the <a href="http://www.erlang.org/doc/man/io.html#fwrite-1">io:format documentation</a>.</p>
<h2><a class="header" href="#matching-and-guards-and-scope-of-variables" id="matching-and-guards-and-scope-of-variables">Matching and Guards and Scope of Variables</a></h2>
<p>In the previous section we wrote a little example program for converting temperatures. In creating programs like that with special data structures (in our case, a list of cities and their temperatures), it's often useful to create utility functions which make working with our data more convenient. We will explore that below and use these functions to introduce some new concepts.</p>
<h3><a class="header" href="#a-utility-function" id="a-utility-function">A Utility Function</a></h3>
<p>In this case, it could be useful to find the maximum and minimum temperature in our data. We can add support for this by creating the necessary code little bit at a time. Let's start with creating functions for finding the maximum value of the elements of a property list:</p>
<pre><code class="language-lisp">(defmodule tut9
  (export (list-max 1)))

(defun list-max
  (((cons head tail))
   (list-max tail head)))

(defun list-max
  (('() results)
   results)
  (((cons head tail) result-so-far) (when (&gt; head result-so-far))
   (list-max tail head))
  (((cons head tail) result-so-far)
   (list-max tail result-so-far)))
</code></pre>
<p>Then, in the LFE REPL:</p>
<pre><code class="language-lisp">lfe&gt; (c &quot;tut9.lfe&quot;)
#(module tut9)
lfe&gt; (tut9:list-max '(1 2 3 4 5 6 7 4 3 2 1))
7
</code></pre>
<h3><a class="header" href="#pattern-matching" id="pattern-matching">Pattern Matching</a></h3>
<p>Before we talk about pattern matching, let's clarify why we have two different functions with the same name. Note that the two <code>list-max</code> functions above each take a different number of arguments (parameters). Or, another way of saying it: they have different <em>arity</em>. In LFE, functions having the same name but differing in arity are actually <em>different functions</em>. Where we need to distinguish between these functions we write <code>&lt;function name&gt;/&lt;arity&gt;</code>, where <code>&lt;arity&gt;</code> is an integer representing the number of arguments that function takes. For our example above, we would write <code>list-max/1</code> and <code>list-max/2</code>.</p>
<p>The next thing we should explain is the arguments for the <code>list-max/2</code> function, since that probably looks pretty strange the first time you see it. If you look closely, you will see that there are three clauses in <code>list-max/2</code> and each clause stats with the function arguments for that clause; in order, they are:</p>
<ul>
<li>an empty list and <code>results</code></li>
<li>a <code>cons</code> and <code>results-so-far</code> with something called a <em>guard</em> (more on that soon)</li>
<li>a <code>cons</code> and <code>results-so-far</code> just by itself</li>
</ul>
<p>What each of these are doing is what is called <em>pattern matching</em> in LFE: if the arguments passed to <code>list-max/2</code> match the first pattern, the first clause gets executed and the others don't. If the first one does not match, the second one is tried, and so on.</p>
<p>So what is being &quot;matched&quot; here? Well, the first clause will match if it's first argument is an empty list. The second and third will match if the first element is a list. The second has something more, though: let's take a closer look.</p>
<h3><a class="header" href="#guards" id="guards">Guards</a></h3>
<p>In the second clause of <code>list-max/2</code> we see a new form: <code>(when ...)</code> which contains a comparison operation. The special form <code>when</code> is a something we can use with LFE patterns to limit a match. In this case we use it to say: &quot;only use this function clause if <code>head</code> is greater than <code>result-so-far</code>. We call tests of this type a <em>guard</em>. If the guard isn't true (usually referred to as &quot;if the guard fails&quot;), then we try the next part of the function.</p>
<h3><a class="header" href="#stepping-through-the-function" id="stepping-through-the-function">Stepping Through the Function</a></h3>
<p>Now that we know how there can be two functions with the same name and how the arguments for <code>list-max/2</code> are working, let's step through the functions above. They represent an example of walking through a list and &quot;carrying&quot; a value as we do so, in this case <code>result-so-far</code> is the variable that carries a value as we walk. <code>list-max/1</code> simply assumes that the max value of the list is the head of the list and calls <code>list-max/2</code> with the rest of the list and the value of the head of the list, in the above this would be <code>(list-max '(2 3 4 5 6 7 4 3 2 1) 1)</code>. If we tried to use <code>list-max/1</code> with an empty list or tried to use it with something which isn't a list at all, we would cause an error. The LFE philosophy is not to handle errors of this type in the function they occur, but to do so elsewhere. More about this later.</p>
<p>In <code>list-max/2</code> we walk down the list and use <code>head</code> instead of <code>result-so-far</code> when <code>head</code> is greater than <code>result-so-far</code>. In this function, if <code>head</code> <em>isn't</em> greater than <code>result-so-far</code> then it must be smaller or equal to it, and the next clause is executed under this condition.</p>
<p>To change the above program to one which works out the minimum value of the element in a list, all we would need to do is to write <code>&lt;</code> instead of <code>&gt;</code> in the guard ... but it would be wise to change the name of the function to <code>list-min</code> :-).</p>
<h3><a class="header" href="#scope-and-let" id="scope-and-let">Scope and <code>let</code></a></h3>
<p>In a function, the arguments that are passed to it are <em>in scope</em> or &quot;accessible&quot; for all of that function. In another function which has been passed its own arguments, only those are in scope; arguments from other functions are not available for use.</p>
<p>In the case of functions which are pattern matching on the arguments, like our <code>list-max/2</code>, we have three clauses, each with their own arguments and each with their own scope. The parentheses at the beginning of each clause mark this scope. In that case, the <code>results</code> variable is only available in the first clause; it is not in scope for the second two clauses.</p>
<p>But passing arguments to functions and pattern matching function arguments are not the only ways in which you can bind a value to a variable. There is a special form in LFE (and other Lisps) called <code>let</code>. Let's<sup class="footnote-reference"><a href="#1">1</a></sup> take a look, shall we? Here's another way we could have written <code>list-max/2</code>:</p>
<pre><code class="language-lisp">(defun list-max
  (('() results)
   results)
  (((cons head tail) result-so-far) (when (&gt; head result-so-far))
   (let ((new-result-so-far head))
     (list-max tail new-result-so-far)))
  (((cons head tail) result-so-far)
   (list-max tail result-so-far)))
</code></pre>
<p>We only made a change to the second clause: we assigned the value of <code>head</code> to the variable <code>new-result-so-far</code>. This assignment didn't involve any computation or new values, it was essentially just a &quot;renaming&quot; mostly for the sake of demonstration, and arguably to make it more clear the purpose of the value stored in <code>head</code>.</p>
<hr />
<p><sup class="footnote-reference"><a href="#1">1</a></sup> We are not going to apologize for that pun.</p>
<h2><a class="header" href="#more-about-lists" id="more-about-lists">More About Lists</a></h2>
<h3><a class="header" href="#the-cons-form" id="the-cons-form">The <code>cons</code> Form</a></h3>
<p>Remember how we used <code>cons</code> to &quot;extract&quot; head and tail values of a list when matching them? In the REPL, we would do it like so:</p>
<pre><code class="language-lisp">lfe&gt; (set (cons head tail) (list 'Paris 'London 'Rome))
(Paris London Rome)
lfe&gt; head
Paris
lfe&gt; tail
(London Rome)
</code></pre>
<p>Well, that's not how <code>cons</code> started life<sup class="footnote-reference"><a href="#1">1</a></sup>; it's original use was in &quot;cons&quot;tructing lists, not taking them apart. Here is some classic usage:</p>
<pre><code class="language-lisp">lfe&gt; (cons 'Madrid tail)
(Madrid London Rome)
</code></pre>
<p>Let's look at a more involved example where we use <code>cons</code>es to reverse the order of a list:</p>
<pre><code class="language-lisp">(defmodule tut10
  (export all))

(defun reverse (list)
  (reverse list '()))

(defun reverse
  (((cons head tail) reversed-list)
   (reverse tail (cons head reversed-list)))
  (('() reversed-list)
   reversed-list))
</code></pre>
<p>Then, in the REPL:</p>
<pre><code class="language-lisp">lfe&gt; (c &quot;tut10.lfe&quot;)
#(module tut10)
lfe&gt; (tut10:reverse (list 1 2 3))
(3 2 1)
</code></pre>
<p>Consider how <code>reversed-list</code> is built: it starts as <code>'()</code>, we then successively take off the heads of the list that was provided and add these heads to the the <code>reversed-list</code> variable, as detailed by the following:</p>
<pre><code class="language-lisp">(reverse (cons 1 '(2 3)) '()) =&gt; (reverse '(2 3) (cons 1 '()))
(reverse (cons 2 '(3)) '(1)) =&gt; (reverse '(3) (cons 2 '(1)))
(reverse (cons 3 '()) (2 1)) =&gt; (reverse '() (cons 3 '(2 1)))
(reverse '() '(3 2 1)) =&gt; '(3 2 1)
</code></pre>
<p>The Erlang module <code>lists</code> contains a lot of functions for manipulating lists, for example for reversing them -- our work above was done for demonstration and pedagogical purposes. For serious applications, one should prefer functions in the Erlang standard library.<sup class="footnote-reference"><a href="#2">2</a></sup></p>
<h3><a class="header" href="#processing-lists" id="processing-lists">Processing Lists</a></h3>
<p>Now lets get back to the cities and temperatures, but take a more structured approach this time. First let's convert the whole list to Celsius as follows:</p>
<pre><code class="language-lisp">(defmodule tut11
  (export (format-temps 1)))

(defun format-temps (cities)
  (-&gt;c cities))

(defun -&gt;c
  (((cons (tuple name (tuple 'F temp)) tail))
   (let ((converted (tuple name (tuple 'C (/ (* (- temp 32) 5) 9)))))
     (cons converted (-&gt;c tail))))
  (((cons city tail))
   (cons city (-&gt;c tail)))
  (('())
   '()))
</code></pre>
<p>Now let's test this new function:</p>
<pre><code class="language-lisp">lfe&gt; (c &quot;tut11.lfe&quot;)
#(module tut11)
lfe&gt; (tut11:format-temps
    '(#(Moscow #(C 10))
      #(Cape-Town #(F 70))
      #(Stockholm #(C -4))
      #(Paris #(F 28))
      #(London #(F 36)))))
(#(Moscow #(C 10))
 #(Cape-Town #(C 21.11111111111111))
 #(Stockholm #(C -4))
 #(Paris #(C -2.2222222222222223))
 #(London #(C 2.2222222222222223)))
</code></pre>
<p>Let's look at this, bit-by-bit. In the first function:</p>
<pre><code class="language-lisp">(defun format-temps (cities)
  (-&gt;c cities))
</code></pre>
<p>we see that <code>format-temps/1</code> calls <code>-&gt;c/1</code>. <code>-&gt;c/1</code> takes off the head of the List <code>cities</code> and converts it to Celsius if needed. The <code>cons</code> function is used to add the (maybe) newly converted city to the converted rest of the list:</p>
<pre><code class="language-lisp">(cons converted (-&gt;c tail))
</code></pre>
<p>or</p>
<pre><code class="language-lisp">(cons city (-&gt;c tail))
</code></pre>
<p>We go on doing this until we get to the end of the list (i.e. the list is empty):</p>
<pre><code class="language-lisp">  (('())
   '())
</code></pre>
<p>Now that we have converted the list, we should add a function to print it:</p>
<pre><code class="language-lisp">(defmodule tut12
  (export (format-temps 1)))

(defun format-temps (cities)
  (print-temps (-&gt;c cities)))

(defun -&gt;c
  (((cons (tuple name (tuple 'F temp)) tail))
   (let ((converted (tuple name (tuple 'C (/ (* (- temp 32) 5) 9)))))
     (cons converted (-&gt;c tail))))
  (((cons city tail))
   (cons city (-&gt;c tail)))
  (('())
   '()))

(defun print-temps
  (((cons (tuple name (tuple 'C temp)) tail))
   (io:format &quot;~-15w ~w c~n&quot; (list name temp))
   (print-temps tail))
  (('())
   'ok))
</code></pre>
<p>Let's take a look:</p>
<pre><code class="language-lisp">lfe&gt; (c &quot;tut12.lfe&quot;)
#(module tut12)
lfe&gt; (tut12:format-temps
    '(#(Moscow #(C 10))
      #(Cape-Town #(F 70))
      #(Stockholm #(C -4))
      #(Paris #(F 28))
      #(London #(F 36)))))
'Moscow'        10 c
'Cape-Town'     21.11111111111111 c
'Stockholm'     -4 c
'Paris'         -2.2222222222222223 c
'London'        2.2222222222222223 c
ok
</code></pre>
<h3><a class="header" href="#utility-functions-revisited" id="utility-functions-revisited">Utility Functions Revisited</a></h3>
<p>Remember a few sections back when we created the utility function for finding the maximum value in a list? Let's put that into action now: we want to add a function which finds the cities with the maximum and minimum temperatures:</p>
<pre><code class="language-lisp">(defun find-max-min
  (((cons city tail))
    (find-max-min tail city city)))

(defun find-max-min
  (((cons head tail) max-city min-city)
   (find-max-min tail
                 (compare-max head max-city)
                 (compare-min head min-city)))
  (('() max-city min-city)
   (tuple max-city min-city)))

(defun compare-max
  (((= (tuple name1 (tuple 'C temp1)) city1)
    (= (tuple name2 (tuple 'C temp2)) city2))
   (if (&gt; temp1 temp2)
     city1
     city2)))

(defun compare-min
  (((= (tuple name1 (tuple 'C temp1)) city1)
    (= (tuple name2 (tuple 'C temp2)) city2))
   (if (&lt; temp1 temp2)
     city1
     city2)))
</code></pre>
<h3><a class="header" href="#the-complete-example" id="the-complete-example">The Complete Example</a></h3>
<pre><code class="language-lisp">(defmodule tut13
  (export (format-temps 1)))

(defun format-temps (cities)
  (let* ((converted (-&gt;c cities)))
    (print-temps converted)
    (print-max-min (find-max-min converted))))

(defun -&gt;c
  (((cons (tuple name (tuple 'F temp)) tail))
   (let ((converted (tuple name (tuple 'C (/ (* (- temp 32) 5) 9)))))
     (cons converted (-&gt;c tail))))
  (((cons city tail))
   (cons city (-&gt;c tail)))
  (('())
   '()))

(defun print-temps
  (((cons (tuple name (tuple 'C temp)) tail))
   (io:format &quot;~-15w ~w c~n&quot; (list name temp))
   (print-temps tail))
  (('())
   'ok))

(defun find-max-min
  (((cons city tail))
    (find-max-min tail city city)))

(defun find-max-min
  (((cons head tail) max-city min-city)
   (find-max-min tail
                 (compare-max head max-city)
                 (compare-min head min-city)))
  (('() max-city min-city)
   (tuple max-city min-city)))

(defun compare-max
  (((= (tuple name1 (tuple 'C temp1)) city1)
    (= (tuple name2 (tuple 'C temp2)) city2))
   (if (&gt; temp1 temp2)
     city1
     city2)))

(defun compare-min
  (((= (tuple name1 (tuple 'C temp1)) city1)
    (= (tuple name2 (tuple 'C temp2)) city2))
   (if (&lt; temp1 temp2)
     city1
     city2)))

(defun print-max-min
  (((tuple (tuple max-name (tuple 'C max-temp))
           (tuple min-name (tuple 'C min-temp))))
   (io:format &quot;Max temperature was ~w c in ~w~n&quot; (list max-temp max-name))
   (io:format &quot;Min temperature was ~w c in ~w~n&quot; (list min-temp min-name))))
</code></pre>
<p>Let's try it out:</p>
<pre><code class="language-lisp">lfe&gt; (c &quot;tut13.lfe&quot;)
#(module tut13)
lfe&gt; (tut13:format-temps
    '(#(Moscow #(C 10))
      #(Cape-Town #(F 70))
      #(Stockholm #(C -4))
      #(Paris #(F 28))
      #(London #(F 36)))))
'Moscow'        10 c
'Cape-Town'     21.11111111111111 c
'Stockholm'     -4 c
'Paris'         -2.2222222222222223 c
'London'        2.2222222222222223 c
Max temperature was 21.11111111111111 c in 'Cape-Town'
Min temperature was -4 c in 'Stockholm'
ok
</code></pre>
<p>As you may have noticed, that program isn't the most <em>efficient</em> way of doing this, since we walk through the list of cities four times. But it is better to first strive for clarity and correctness and to make programs efficient only if really needed.</p>
<hr />
<p><sup class="footnote-reference"><a href="#1">1</a></sup> Way back in the prehistoric times when large, building-size computers still roamed the earth and the languages which ran on them were tiny and furry, Lisp came along with only a handful of forms: <code>cons</code> was one of them, and it was used to construct lists, one cell at a time.</p>
<p><sup class="footnote-reference"><a href="#2">2</a></sup> More information about this <code>lists</code> module is available <a href="http://www.erlang.org/doc/man/lists.html">here</a>.</p>
<h2><a class="header" href="#conditionals" id="conditionals">Conditionals</a></h2>
<p>In the module <code>tut13.lfe</code>, we saw our first conditional, the <code>(if ...)</code> form. We're going to spend the rest of this section discussing <code>if</code>, <code>cond</code>, <code>case</code>, as well as the use of guards and pattern matching to form conditional code branches.</p>
<h3><a class="header" href="#the-if-form" id="the-if-form">The <code>if</code> Form</a></h3>
<p>In the previous section, we wrote the function <code>find-max-min/3</code> to work out the maximum and minimum temperature. This work was delegated to two helper functions:</p>
<ul>
<li><code>compare-max/2</code></li>
<li><code>compare-min/2</code></li>
</ul>
<p>In both of those functions, we introduced the new <code>if</code> form. If works as follows:</p>
<pre><code class="language-lisp">(if &lt;predicate&gt;
  &lt;expression1&gt;
  &lt;expression2&gt;)
</code></pre>
<p>where <code>&lt;expression1&gt;</code> is executed if <code>&lt;predicate&gt;</code> evaluates to <code>true</code> and <code>&lt;expression2&gt;</code> is executed if <code>&lt;predicate&gt;</code> evaluates to <code>false</code>. If you have used other programming languages, then this will be quite familiar to you. If you have not, if should remind you a bit of the logic we looked at when discussing guards.</p>
<p>We can see it in action with the following LFE session in the REPL:</p>
<pre><code class="language-lisp">lfe&gt; (if (=:= 1 1) &quot;They are equal!&quot; &quot;They are *not* equal!&quot;)
&quot;They are equal!&quot;
lfe&gt; (if (=:= 2 1) &quot;They are equal!&quot; &quot;They are *not* equal!&quot;)
&quot;They are *not* equal!&quot;
</code></pre>
<p>Or -- you will be more familiar with this -- our code from the last section:</p>
<pre><code class="language-lisp">(if (&lt; temp1 temp2)
  city1
  city2)
</code></pre>
<p>where, if <code>temp1</code> is less than <code>temp2</code>, the value stored in <code>city1</code> is returned.</p>
<p>So the <code>if</code> form works for two conditions. What about 3? 10? 100? Well, for the situations were we want to check multiple conditions, we'll need the <code>cond</code> form.</p>
<h3><a class="header" href="#the-cond-form" id="the-cond-form">The <code>cond</code> Form</a></h3>
<pre><code class="language-lisp">(cond (&lt;predicate1&gt; &lt;expression1&gt;)
      (&lt;predicate2&gt; &lt;expression2&gt;)
      (&lt;predicate3&gt; &lt;expression3&gt;)
      ...
      (&lt;predicaten&gt; &lt;expressionn&gt;))
</code></pre>
<p>A given expression is only executed if its accompanying predicate evaluates to <code>true</code>. The <code>cond</code> returns the value of the expression for the first predicate that evaluates to <code>true</code>. Using <code>cond</code>, our temperature test would look like this:</p>
<pre><code class="language-lisp">(cond ((&lt; temp1 temp2) city1)
      ((&gt;= temp1 temp2) city2))
</code></pre>
<p>Here's an example which takes advantage of <code>cond</code> supporting more than two logic branches:</p>
<pre><code class="language-lisp">(cond ((&gt; x 0) x)
      ((=:= x 0) 0)
      ((&lt; x 0) (- x)))
</code></pre>
<p>Note that each predicate is an expression with it's own parentheses around it; on its left is the opening parenthenis for that particular branch of the <code>cond</code>.</p>
<p>Often times when using <code>cond</code> one needs a &quot;default&quot; or &quot;fall-through&quot; option to be used when no other condition is met. Since it's the last one, and we need it to evaluate to <code>true</code> we simply set the last condition to <code>true</code> when we need a default. Here's a rather silly example:</p>
<pre><code class="language-lisp">(cond ((lists:member x '(1 2 3)) &quot;First three&quot;)
      ((=:= x 4) &quot;Is four&quot;)
      ((&gt;= x 5) &quot;More than four&quot;)
      ('true &quot;You chose poorly&quot;))
</code></pre>
<p>Any number that is negative will be caught by the last condition.</p>
<p>In case you're wondering, yes: <code>cond</code> works with patterns as well. Let's take a look.</p>
<h3><a class="header" href="#the-extended-cond-form" id="the-extended-cond-form">The Extended <code>cond</code> Form</a></h3>
<p>When we talked about <code>cond</code> above, we only discussed the form as any Lisper would be familiar. However, LFE has extended <code>cond</code> with additional capabilities provided via pattern matching. LFE's <code>cond</code> has the following general form when this is taken into consideration:</p>
<pre><code class="language-lisp">(cond (&lt;cond-clause1&gt;)
      (&lt;cond-clause2&gt;)
      (&lt;cond-clause3&gt;)
      ...
      (&lt;cond-clausen&gt;))
</code></pre>
<p>where each <code>&lt;cond-clause&gt;</code> could be either as it is in the regular <code>cond</code>, <code>&lt;predicate&gt; &lt;expression&gt;</code> or it could be <code>(?= &lt;pattern&gt; [&lt;guard&gt;] &lt;expression&gt;)</code> -- the latter being the extended form (with an optional guard). When using the extended form, instead of evaluating a predicate for its boolean result, the data passed to the <code>cond</code> is matched against the defined patterns: if the pattern match succeeds, then the associated expression is evaluated. Here's an example:</p>
<pre><code class="language-lisp">(cond ((?= (cons head '()) x)
       &quot;Only one element&quot;)
      ((?= (list 1 2) x)
       &quot;Two element list&quot;)
      ((?= (list a _) (when (is_atom a)) x)
       &quot;List starts with an atom&quot;)
      ((?= (cons _ (cons a _)) (when (is_tuple a)) x)
       &quot;Second element is a tuple&quot;)
      ('true &quot;Anything goes&quot;))
</code></pre>
<p>That form is not that often used, but it can be very practical.</p>
<h3><a class="header" href="#the-case-form" id="the-case-form">The <code>case</code> Form</a></h3>
<p>The <code>case</code> form is useful for situations where you want to check for multiple possible values of the same expression. Without guards, the general form for <code>case</code> is the following:</p>
<pre><code class="language-lisp">(case &lt;expression&gt;
  (&lt;pattern1&gt; &lt;expression1&gt;)
  (&lt;pattern2&gt; &lt;expression2&gt;)
  ...
  (&lt;patternn&gt; &lt;expressionn&gt;))
</code></pre>
<p>So we could rewrite the code for the non-extended <code>cond</code> above with the following <code>case</code>:</p>
<pre><code class="language-lisp">(case x
  ((cons head '())
   &quot;Only one element&quot;)
  ((list 1 2)
   &quot;Two element list&quot;)
  ((list 'a _)
    &quot;List starts with 'a'&quot;)
  (_ &quot;Anything goes&quot;))
</code></pre>
<p>The following will happen with the <code>case</code> defined above:</p>
<ul>
<li>Any 1-element list will be matched by the first clause.</li>
<li>A 2-element list of <code>1</code> and <code>2</code> (in that order) will match the second clause.</li>
<li>Any list whose first element is the atom <code>a</code> will match the third caluse.</li>
<li>Anything <em>not</em> matching the first three clauses will be matched by the fourth.</li>
</ul>
<p>With guards, the case has the following general form:</p>
<pre><code class="language-lisp">(case &lt;expression&gt;
  (&lt;pattern1&gt; [&lt;guard1&gt;] &lt;expression1&gt;)
  (&lt;pattern2&gt; [&lt;guard2&gt;] &lt;expression2&gt;)
  ...
  (&lt;patternn&gt; [&lt;guardn&gt;] &lt;expressionn&gt;))
</code></pre>
<p>Let's update the previous example with a couple of guards:</p>
<pre><code class="language-lisp">(case x
  ((cons head '())
   &quot;Only one element&quot;)
  ((list 1 2)
   &quot;Two element list&quot;)
  ((list a _) (when (is_atom a))
    &quot;List starts with an atom&quot;)
  ((cons _ (cons a _)) (when (is_tuple a))
    &quot;Second element is a tuple&quot;)
  (_ &quot;Anything goes&quot;))
</code></pre>
<p>This changes the logic of the previous example in the following ways:</p>
<ul>
<li>Any list whose first element is an atom will match the third clause.</li>
<li>Any list whose second element is a tuple will match the fourth clause.</li>
<li>Anything <em>not</em> matching the first four clauses will be matched by the fifth.</li>
</ul>
<h3><a class="header" href="#function-heads-as-conditionals" id="function-heads-as-conditionals">Function Heads as Conditionals</a></h3>
<p>Another very common way to express conditional logic in LFE is through the use of pattern matching in function heads. This has the capacity to make code <em>very</em> concise while also remaining clear to read -- thus its prevelant use.</p>
<p>As we've seen, a regular LFE function takes the following form (where the arguments are optional):</p>
<pre><code class="language-lisp">(defun &lt;function-name&gt; ([&lt;arg1&gt; ... &lt;argn&gt;])
  &lt;body&gt;)
</code></pre>
<p>When pattern matching in the function head, the form is as follows:</p>
<pre><code class="language-lisp">(defun &lt;function-name&gt;
 ((&lt;pattern1&gt;) [&lt;guard1&gt;]
   &lt;body1&gt;)
 ((&lt;pattern2&gt;) [&lt;guard2&gt;]
   &lt;body2&gt;)
 ...
 ((&lt;patternn&gt;) [&lt;guardn&gt;]
   &lt;bodyn&gt;))
</code></pre>
<p>Note that simple patterns with no expressions are just regular function arguments. In other words <code>&lt;pattern1&gt;</code>, <code>&lt;pattern2&gt;</code>, etc., may be either a full pattern or they may be simple function arguments. The guards are optional.</p>
<p>Let's try this out by rewriting the silly <code>case</code> example above to use a function with pattern-matching in the function heads:</p>
<pre><code class="language-lisp">(defun check-val
  (((cons head '()))
   &quot;Only one element&quot;)
  (((list 1 2))
   &quot;Two element list&quot;)
  (((list a _)) (when (is_atom a))
    &quot;List starts with an atom&quot;)
  (((cons _ (cons a _))) (when (is_tuple a))
    &quot;Second element is a tuple&quot;)
  ((_) &quot;Anything goes&quot;))
</code></pre>
<p>If you run that in the REPL, you can test it out with the following:</p>
<pre><code class="language-lisp">lfe&gt; (check-val '(1))
&quot;Only one element&quot;
lfe&gt; (check-val '(a 1))
&quot;List starts with an atom&quot;
lfe&gt; (check-val '(1 #(b 2)))
&quot;Second element is a tuple&quot;
lfe&gt; (check-val 42)
&quot;Anything goes&quot;
</code></pre>
<p>And there you have LFE function definitions with much of the power of <code>if</code>, <code>cond</code>, and <code>case</code>!</p>
<p>Let's use some of these forms in actual code now ...</p>
<h3><a class="header" href="#example-inches-and-centimeters" id="example-inches-and-centimeters">Example: Inches and Centimeters</a></h3>
<p>[forthcoming]</p>
<p>[tutorial #14]</p>
<h3><a class="header" href="#example-leap-years" id="example-leap-years">Example: Leap Years</a></h3>
<p>[forthcoming]</p>
<p>[tutorial #15]</p>
<h2><a class="header" href="#built-in-functions" id="built-in-functions">Built-in Functions</a></h2>
<p>[forthcoming]</p>
<p>Ticket: <a href="https://github.com/lfe/tutorial/issues/7">https://github.com/lfe/tutorial/issues/7</a></p>
<h2><a class="header" href="#higher-order-functions" id="higher-order-functions">Higher Order Functions</a></h2>
<p>[forthcoming]</p>
<h3><a class="header" href="#refactor-temperature-convertion-example" id="refactor-temperature-convertion-example">Refactor Temperature Convertion Example</a></h3>
<p>[tutorial #16]</p>
<p>[tutorial #17]</p>
<p>Ticket: <a href="https://github.com/lfe/tutorial/issues/8">https://github.com/lfe/tutorial/issues/8</a></p>
<h1><a class="header" href="#concurrent-programming" id="concurrent-programming">Concurrent Programming</a></h1>
<p>In this chapter we will look at the basics of concurrent programming in LFE.</p>
<h2><a class="header" href="#processes" id="processes">Processes</a></h2>
<p>One of the main reasons for using LFE/Erlang instead of other functional languages is Erlang/LFE's ability to handle concurrency and distributed programming. By concurrency we mean programs which can handle several threads of execution at the same time. For example, modern operating systems would allow you to use a word processor, a spreadsheet, a mail client and a print job all running at the same time. Of course each processor (CPU) in the system is probably only handling one thread (or job) at a time, but it swaps between the jobs a such a rate that it gives the illusion of running them all at the same time. It is easy to create parallel threads of execution in an LFE program and it is easy to allow these threads to communicate with each other. In LFE we call each thread of execution a <em>process</em>.</p>
<p>(Aside: the term &quot;process&quot; is usually used when the threads of execution share no data with each other and the term &quot;thread&quot; when they share data in some way. Threads of execution in LFE share no data, that's why we call them processes).</p>
<p>The LFE BIF <code>spawn</code> is used to create a new process: <code>(spawn module exported-function list-of-arguments)</code>. Consider the following module:</p>
<pre><code class="language-lisp">(defmodule tut18
  (export (start 0) (say-something 2)))

(defun say-something
  ([what 0] 'done)
  ([what times]
   (lfe_io:format &quot;~p~n&quot; (list what))
   (say-something what (- times 1))))

(defun start ()
  (spawn 'tut18 'say-something '(hello 3))
  (spawn 'tut18 'say-something '(goodbye 3)))
</code></pre>
<pre><code class="language-lisp">lfe&gt; (c &quot;tut18.lfe&quot;)
#(module tut18)
lfe&gt; (tut18:say-something 'hello 3)
hello
hello
hello
done
</code></pre>
<p>We can see that function <code>say-something</code> writes its first argument the number of times specified by second argument. Now look at the function <code>start</code>. It starts two LFE processes, one which writes &quot;hello&quot; three times and one which writes &quot;goodbye&quot; three times. Both of these processes use the function <code>say-something</code>. Note that a function used in this way by <code>spawn</code> to start a process must be exported from the module (i.e. in the (export ... ) at the start of the module).</p>
<pre><code class="language-lisp">lfe&gt; (tut18:start)
&lt;0.37.0&gt;
hello
goodbye
lfe&gt; hello
goodbye
hello
goodbye
</code></pre>
<p>Notice that it didn't write &quot;hello&quot; three times and then &quot;goodbye&quot; three times, but the first process wrote a &quot;hello&quot;, the second a &quot;goodbye&quot;, the first another &quot;hello&quot; and so forth. But where did the &lt;0.37.0&gt; come from? The return value of a function is of course the return value of the last &quot;thing&quot; in the function. The last thing in the function <code>start</code> is</p>
<pre><code class="language-lisp">(spawn 'tut18 'say-something '(goodbye 3))
</code></pre>
<p><code>spawn</code> returns a <em>process identifier</em>, or <em>pid</em>, which uniquely identifies the process. So &lt;0.37.0&gt; is the pid of the spawn function call above. We will see how to use pids in the next example.</p>
<p>Note as well that we have used ~p instead of ~w in <code>lfe_io:format</code>. To quote the manual: &quot;~p Writes the data with standard syntax in the same way as ~w, but breaks terms whose printed representation is longer than one line into many lines and indents each line sensibly. It also tries to detect lists of printable characters and to output these as strings&quot;.</p>
<h2><a class="header" href="#message-passing" id="message-passing">Message Passing</a></h2>
<p>In the following example we create two processes which send messages to each other a number of times.</p>
<pre><code class="language-lisp">(defmodule tut19
  (export (start 0) (ping 2) (pong 0)))

(defun ping
  ((0 pong-pid)
   (! pong-pid 'finished)
   (lfe_io:format &quot;Ping finished~n&quot; ()))
  ((n pong-pid)
   (! pong-pid (tuple 'ping (self)))
   (receive
     ('pong (lfe_io:format &quot;Ping received pong~n&quot; ())))
   (ping (- n 1) pong-pid)))

(defun pong ()
  (receive
    ('finished
     (lfe_io:format &quot;Pong finished~n&quot; ()))
    ((tuple 'ping ping-pid)
     (lfe_io:format &quot;Pong received ping~n&quot; ())
     (! ping-pid 'pong)
     (pong))))

(defun start ()
  (let ((pong-pid (spawn 'tut19 'pong ())))
    (spawn 'tut19 'ping (list 3 pong-pid))))
</code></pre>
<pre><code class="language-lisp">lfe&gt; (c &quot;tut19.lfe&quot;)
#(module tut19)
lfe&gt; (tut19:start)
&lt;0.36.0&gt;
lfe&gt; Pong received ping
Ping received pong
Pong received ping
Ping received pong
Pong received ping
Ping received pong
Ping finished
Pong finished
</code></pre>
<p>The function <code>start</code> first creates a process, let's call it &quot;pong&quot;:</p>
<pre><code class="language-lisp">(let ((pong-pid (spawn 'tut19 'pong ())))
</code></pre>
<p>This process executes <code>(tut19:pong)</code>. <code>pong-pid</code> is the process identity of the &quot;pong&quot; process. The function <code>start</code> now creates another process &quot;ping&quot;.</p>
<pre><code class="language-lisp">(spawn 'tut19 'ping (list 3 pong-pid))))
</code></pre>
<p>this process executes:</p>
<pre><code class="language-lisp">(tut19:ping (list 3 pong-pid))
</code></pre>
<p>&lt;0.36.0&gt; is the return value from the <code>start</code> function.</p>
<p>The process &quot;pong&quot; now does:</p>
<pre><code class="language-lisp">(receive
  ('finished
   (lfe_io:format &quot;Pong finished~n&quot; ()))
  ((tuple 'ping ping-pid)
   (lfe_io:format &quot;Pong received ping~n&quot; ())
   (! ping-pid 'pong)
   (pong)))
</code></pre>
<p>The <code>receive</code> construct is used to allow processes to wait for messages from other processes. It has the format:</p>
<pre><code class="language-lisp">(receive
  (pattern1
   actions1)
  (pattern2
   actions2)
  ....
  (patternN
   actionsN))
</code></pre>
<p>Messages between LFE processes are simply valid LFE terms. I.e. they can be lists, tuples, integers, atoms, pids etc.</p>
<p>Each process has its own input queue for messages it receives. New messages received are put at the end of the queue. When a process executes a <code>receive</code>, the first message in the queue is matched against the first pattern in the <code>receive</code>, if this matches, the message is removed from the queue and the actions corresponding to the the pattern are executed.</p>
<p>However, if the first pattern does not match, the second pattern is tested, if this matches the message is removed from the queue and the actions corresponding to the second pattern are executed. If the second pattern does not match the third is tried and so on until there are no more pattern to test. If there are no more patterns to test, the first message is kept in the queue and we try the second message instead. If this matches any pattern, the appropriate actions are executed and the second message is removed from the queue (keeping the first message and any other messages in the queue). If the second message does not match we try the third message and so on until we reach the end of the queue. If we reach the end of the queue, the process blocks (stops execution) and waits until a new message is received and this procedure is repeated.</p>
<p>Of course the LFE implementation is &quot;clever&quot; and minimizes the number of times each message is tested against the patterns in each <code>receive</code>.</p>
<p>Now back to the ping pong example.</p>
<p>&quot;Pong&quot; is waiting for messages. If the atom <code>finished</code> is received, &quot;pong&quot; writes &quot;Pong finished&quot; to the output and as it has nothing more to do, terminates. If, however, it receives a message with the format:</p>
<pre><code class="language-lisp">#(ping ping-pid)
</code></pre>
<p>it writes &quot;Pong received ping&quot; to the output and sends the atom <code>pong</code> to the process &quot;ping&quot;:</p>
<pre><code class="language-lisp">(! ping-pid 'pong)
</code></pre>
<p>Note how &quot;!&quot; is used to send messages. The syntax of &quot;!&quot; is:</p>
<pre><code class="language-lisp">(! pid message)
</code></pre>
<p>I.e. <code>message</code> (any LFE term) is sent to the process with indentity <code>pid</code>.</p>
<p>After sending the message <code>pong</code>, to the process &quot;ping&quot;, &quot;pong&quot; calls the <code>pong</code> function again, which causes it to get back to the <code>receive</code> again and wait for another message. Now let's look at the process &quot;ping&quot;. Recall that it was started by executing:</p>
<pre><code class="language-lisp">(tut19:ping 3 pong-pid)
</code></pre>
<p>Looking at the function <code>ping/2</code> we see that the second clause of <code>ping/2</code> is executed since the value of the first argument is 3 (not 0) (first clause head is <code>(0 pong-pid)</code>, second clause head is <code>(n pong-pid)</code>, so <code>n</code> becomes 3).</p>
<p>The second clause sends a message to &quot;pong&quot;:</p>
<pre><code class="language-lisp">(! pong-pid (tuple 'ping (self)))
</code></pre>
<p><code>(self)</code> returns the pid of the process which executes <code>(self)</code>, in this case the pid of &quot;ping&quot;. (Recall the code for &quot;pong&quot;, this will land up in the variable <code>ping-pid</code> in the <code>receive</code> previously explained).</p>
<p>&quot;Ping&quot; now waits for a reply from &quot;pong&quot;:</p>
<pre><code class="language-lisp">(receive
  ('pong (lfe_io:format &quot;Ping received pong~n&quot; ())))
</code></pre>
<p>and writes &quot;Ping received pong&quot; when this reply arrives, after which &quot;ping&quot; calls the <code>ping</code> function again.</p>
<pre><code class="language-lisp">(ping (- n 1) pong-pid)
</code></pre>
<p><code>(- n 1)</code> causes the first argument to be decremented until it becomes 0. When this occurs, the first clause of <code>ping/2</code> will be executed:</p>
<pre><code class="language-lisp">(defun ping
  ((0 pong-pid)
   (! pong-pid 'finished)
   (lfe_io:format &quot;Ping finished~n&quot; ()))
</code></pre>
<p>The atom <code>finished</code> is sent to &quot;pong&quot; (causing it to terminate as described above) and &quot;Ping finished&quot; is written to the output. &quot;Ping&quot; then itself terminates as it has nothing left to do.</p>
<h2><a class="header" href="#registered-process-names" id="registered-process-names">Registered Process Names</a></h2>
<p>In the above example, we first created &quot;pong&quot; so as to be able to give the identity of &quot;pong&quot; when we started &quot;ping&quot;. I.e. in some way &quot;ping&quot; must be able to know the identity of &quot;pong&quot; in order to be able to send a message to it. Sometimes processes which need to know each others identities are started completely independently of each other. Erlang thus provides a mechanism for processes to be given names so that these names can be used as identities instead of pids. This is done by using the <code>register</code> BIF:</p>
<pre><code class="language-lisp">(register some-atom pid)
</code></pre>
<p>We will now re-write the ping pong example using this and giving the name <code>pong</code> to the &quot;pong&quot; process:</p>
<pre><code class="language-lisp">(defmodule tut20
  (export (start 0) (ping 1) (pong 0)))

(defun ping
  ((0)
   (! 'pong 'finished)
   (lfe_io:format &quot;Ping finished~n&quot; ()))
  ((n)
   (! 'pong (tuple 'ping (self)))
   (receive
     ('pong (lfe_io:format &quot;Ping received pong~n&quot; ())))
   (ping (- n 1))))

(defun pong ()
  (receive
    ('finished
     (lfe_io:format &quot;Pong finished~n&quot; ()))
    ((tuple 'ping ping-pid)
     (lfe_io:format &quot;Pong received ping~n&quot; ())
     (! ping-pid 'pong)
     (pong))))

(defun start ()
  (let ((pong-pid (spawn 'tut20 'pong ())))
    (register 'pong pong-pid)
    (spawn 'tut20 'ping '(3))))
</code></pre>
<pre><code class="language-lisp">lfe&gt; (c &quot;tut20&quot;)
#(module tut20)
lfe&gt; (tut20:start)
&lt;0.36.0&gt;
lfe&gt; Pong received ping
Ping received pong
Pong received ping
Ping received pong
Pong received ping
Ping received pong
Ping finished
Pong finished
</code></pre>
<p>In the <code>start/0</code> function,</p>
<pre><code class="language-lisp">(register 'pong pong-pid)
</code></pre>
<p>registers the &quot;pong&quot; process and gives it the name <code>pong</code>. In the &quot;ping&quot; process we can now send messages to <code>pong</code> by:</p>
<pre><code class="language-lisp">(! 'pong (tuple 'ping (self)))
</code></pre>
<p>so that <code>ping/2</code> now becomes <code>ping/1</code> as we don't have to use the argument <code>pong-pid</code>.</p>
<h2><a class="header" href="#distributed-programming" id="distributed-programming">Distributed Programming</a></h2>
<p>Now let's re-write the ping pong program with &quot;ping&quot; and &quot;pong&quot; on different computers. Before we do this, there are a few things we need to set up to get this to work. The distributed LFE/Erlang implementation provides a basic security mechanism to prevent unauthorized access to an Erlang system on another computer (<em>manual</em>). Erlang systems which talk to each other must have the same <em>magic cookie</em>. The easiest way to achieve this is by having a file called <code>.erlang.cookie</code> in your home directory on all machines which on which you are going to run Erlang systems communicating with each other (on Windows systems the home directory is the directory where pointed to by the $HOME environment variable - you may need to set this. On Linux or Unix you can safely ignore this and simply create a file called <code>.erlang.cookie</code> in the directory you get to after executing the command <code>cd</code> without any argument). The <code>.erlang.cookie</code> files should contain one line with the same atom. For example on Linux or Unix in the OS shell:</p>
<pre><code>cd
cat &gt; .erlang.cookie
</code></pre>
<p>Which shows this:</p>
<pre><code>this_is_very_secret
</code></pre>
<p>Let's make it accessible only by the owner of the file:</p>
<pre><code>chmod 400 .erlang.cookie
</code></pre>
<p>Note that this permission change is a requirement.</p>
<p>When you start an LFE/Erlang system which is going to talk to other LFE/Erlang systems, you must give it a name, eg:</p>
<pre><code>lfe -sname my-name
</code></pre>
<p>We will see more details of this later (<em>manual</em>). If you want to experiment with distributed Erlang, but you only have one computer to work on, you can start two separate Erlang systems on the same computer but give them different names. Each Erlang system running on a computer is called an Erlang node.</p>
<p>(Note: <code>erl -sname</code> assumes that all nodes are in the same IP domain and we can use only the first component of the IP address, if we want to use nodes in different domains we use <code>-name</code> instead, but then all IP address must be given in full (<em>manual</em>).</p>
<p>Here is the ping pong example modified to run on two separate nodes:</p>
<pre><code class="language-lisp">(defmodule tut21
  (export (start-ping 1) (start-pong 0) (ping 2) (pong 0)))

(defun ping
  ((0 pong-node)
   (! (tuple 'pong pong-node) 'finished)
   (lfe_io:format &quot;Ping finished~n&quot; ()))
  ((n pong-node)
   (! (tuple 'pong pong-node) (tuple 'ping (self)))
   (receive
     ('pong (lfe_io:format &quot;Ping received pong~n&quot; ())))
   (ping (- n 1) pong-node)))

(defun pong ()
  (receive
    ('finished
     (lfe_io:format &quot;Pong finished~n&quot; ()))
    ((tuple 'ping ping-pid)
     (lfe_io:format &quot;Pong received ping~n&quot; ())
     (! ping-pid 'pong)
     (pong))))

(defun start-pong ()
  (register 'pong (spawn 'tut21 'pong ())))

(defun start-ping (pong-node)
  (spawn 'tut21 'ping (list 3 pong-node)))
</code></pre>
<p>Let us assume we have two computers called gollum and kosken. We will start a node on kosken called ping and then a node on gollum called pong.</p>
<p>On kosken (on a Linux/Unix system):</p>
<pre><code class="language-shell">lfe -sname ping
</code></pre>
<pre><code>Erlang/OTP 17 [erts-6.0] [source-07b8f44] [64-bit] [smp:8:8] [async-threads:10] [hipe] [kernel-poll:false] [dtrace]

LFE Shell V6.0 (abort with ^G)
(ping@kosken)lfe&gt;
</code></pre>
<p>On gollum:</p>
<pre><code class="language-shell">lfe -sname pong
</code></pre>
<pre><code>Erlang/OTP 17 [erts-6.0] [source-07b8f44] [64-bit] [smp:8:8] [async-threads:10] [hipe] [kernel-poll:false] [dtrace]

LFE Shell V6.0 (abort with ^G)
(pong@gollum)lfe&gt;
</code></pre>
<p>Now start the &quot;pong&quot; process on gollum:</p>
<pre><code class="language-lisp">(pong@gollum)lfe&gt; (tut21:start-pong)
true
</code></pre>
<p>and start the &quot;ping&quot; process on kosken (from the code above you will see that a parameter of the <code>start-ping</code> function is the node name of the Erlang system where &quot;pong&quot; is running):</p>
<pre><code class="language-lisp">(ping@kosken)lfe&gt; (tut21:start-ping 'pong@gollum)
&lt;0.41.0&gt;
(ping@kosken)lfe&gt; Ping received pong
Ping received pong
Ping received pong
Ping finished
</code></pre>
<p>Here we see that the ping pong program has run, on the &quot;pong&quot; side we see:</p>
<pre><code class="language-lisp">(pong@gollum)lfe&gt;
Pong received ping
Pong received ping
Pong received ping
Pong finished
</code></pre>
<p>Looking at the <code>tut21</code> code we see that the <code>pong</code> function itself is unchanged, the lines:</p>
<pre><code class="language-lisp">    ((tuple 'ping ping-pid)
     (lfe_io:format &quot;Pong received ping~n&quot; ())
     (! ping-pid 'pong)
</code></pre>
<p>work in the same way irrespective of on which node the &quot;ping&quot; process is executing. Thus Erlang pids contain information about where the process executes so if you know the pid of a process, the &quot;!&quot; operator can be used to send it a message if the process is on the same node or on a different node.</p>
<p>A difference is how we send messages to a registered process on another node:</p>
<pre><code class="language-lisp">   (! (tuple 'pong pong-node) (tuple 'ping (self)))
</code></pre>
<p>We use a tuple <code>#(registered-name node-name)</code> instead of just the <code>registered-name</code>.</p>
<p>In the previous example, we started &quot;ping&quot; and &quot;pong&quot; from the shells of two separate Erlang nodes. <code>spawn</code> can also be used to start processes in other nodes. The next example is the ping pong program, yet again, but this time we will start &quot;ping&quot; in another node:</p>
<pre><code class="language-lisp">(defmodule tut22
  (export (start 1) (ping 2) (pong 0)))

(defun ping
  ((0 pong-node)
   (! (tuple 'pong pong-node) 'finished)
   (lfe_io:format &quot;Ping finished~n&quot; ()))
  ((n pong-node)
   (! (tuple 'pong pong-node) (tuple 'ping (self)))
   (receive
     ('pong (lfe_io:format &quot;Ping received pong~n&quot; ())))
   (ping (- n 1) pong-node)))

(defun pong ()
  (receive
    ('finished
     (lfe_io:format &quot;Pong finished~n&quot; ()))
    ((tuple 'ping ping-pid)
     (lfe_io:format &quot;Pong received ping~n&quot; ())
     (! ping-pid 'pong)
     (pong))))

(defun start (ping-node)
  (register 'pong (spawn 'tut22 'pong ()))
  (spawn ping-node 'tut22 'ping (list 3 (node))))
</code></pre>
<p>The function <code>node/0</code> returns the name of the current node.</p>
<p>Assuming an LFE system called <code>ping</code> (but not the &quot;ping&quot; process) has already been started on kosken, then on gollum we do:</p>
<pre><code class="language-lisp">(pong@gollum)lfe&gt; (tut22:start 'ping@kosken)
&lt;8524.50.0&gt;
(pong@gollum)lfe&gt; Pong received ping
Ping received pong
Pong received ping
Ping received pong
Pong received ping
Ping received pong
Ping finished
Pong finished
</code></pre>
<p>Notice we get all the output on gollum. This is because the io system finds out where the process is spawned from and sends all output there.</p>
<p>Although we do not show here there are no problems with running nodes distributed nodes where some run Erlang and some run LFE. The handling of io will also work the same across mixed LFE and Erlang nodes.</p>
<h2><a class="header" href="#example-messenger" id="example-messenger">Example: Messenger</a></h2>
<p>Now for a larger example. We will make an extremely simple &quot;messenger&quot;. The messenger is a program which allows users to log in on different nodes and send simple messages to each other.</p>
<p>Before we start, let's note the following:</p>
<ul>
<li>
<p>This example will just show the message passing logic no attempt at all has been made to provide a nice graphical user interface - this can of course also be done in LFE - but that's another tutorial.</p>
</li>
<li>
<p>This sort of problem can be solved more easily if you use the facilities in OTP, which will also provide methods for updating code on the fly etc. But again, that's another tutorial.</p>
</li>
<li>
<p>The first program we write will contain some inadequacies as regards handling of nodes which disappear, we will correct these in a later version of the program.</p>
</li>
</ul>
<p>We will set up the messenger by allowing &quot;clients&quot; to connect to a central server and say who and where they are. I.e. a user won't need to know the name of the Erlang node where another user is located to send a message.</p>
<p>File <code>messenger.lfe</code>:</p>
<pre><code class="language-lisp">;;; Message passing utility.
;;; User interface:
;;; (logon name)
;;;     One user at a time can log in from each Erlang node in the
;;;     system messenger: and choose a suitable name. If the name
;;;     is already logged in at another node or if someone else is
;;;     already logged in at the same node, login will be rejected
;;;     with a suitable error message.
;;; (logoff)
;;;     Logs off anybody at at node
;;; (message to-name message)
;;;     sends message to to-name. Error messages if the user of this
;;;     function is not logged on or if to-name is not logged on at
;;;     any node.
;;;
;;; One node in the network of Erlang nodes runs a server which maintains
;;; data about the logged on users. The server is registered as &quot;messenger&quot;
;;; Each node where there is a user logged on runs a client process registered
;;; as &quot;mess-client&quot;
;;;
;;; Protocol between the client processes and the server
;;; ----------------------------------------------------
;;;
;;; To server: (tuple client-pid 'logon user-name)
;;; Reply #(messenger stop user-exists-at-other-node) stops the client
;;; Reply #(messenger logged-on) logon was successful
;;;
;;; To server: (tuple client-pid 'logoff)
;;; Reply: #(messenger logged-off)
;;;
;;; To server: (tuple client-pid 'logoff)
;;; Reply: no reply
;;;
;;; To server: (tuple client-pid 'message-to to-name message) send a message
;;; Reply: #(messenger stop you-are-not-logged-on) stops the client
;;; Reply: #(messenger receiver-not-found) no user with this name logged on
;;; Reply: #(messenger sent) message has been sent (but no guarantee)
;;;
;;; To client: (tuple 'message-from name message)
;;;
;;; Protocol between the &quot;commands&quot; and the client
;;; ----------------------------------------------
;;;
;;; Started: (messenger:client server-node name)
;;; To client: logoff
;;; To client: (tuple 'message-to to-name message)
;;;
;;; Configuration: change the server-node() function to return the
;;; name of the node where the messenger server runs

(defmodule messenger
  (export (start-server 0) (server 1) (logon 1) (logoff 0)
          (message 2) (client 2)))

;;; Change the function below to return the name of the node where the
;;; messenger server runs

(defun server-node () 'messenger@renat)

;;; This is the server process for the &quot;messenger&quot;
;;; the user list has the format [{ClientPid1, Name1},{ClientPid22, Name2},...]

(defun server (user-list)
  (receive
    ((tuple from 'logon name)
     (let ((new-user-list (server-logon from name user-list)))
       (server new-user-list)))
    ((tuple from 'logoff)
     (let ((new-user-list (server-logoff from user-list)))
       (server new-user-list)))
    ((tuple from 'message-to to message)
     (server-transfer from to message user-list)
     ;;(lfe_io:format &quot;list is now: ~p~n&quot; (list user-list))
     (server user-list))))

;;; Start the server

(defun start-server ()
  (register 'messenger (spawn 'messenger 'server '(()))))

;;; Server adds a new user to the user list

(defun server-logon (from name user-list)
  ;; Check if logged on anywhere else
  (if (lists:keymember name 2 user-list)
    (progn                              ;Reject logon
      (! from #(messenger stop user-exists-at-other-node))
      user-list)
    (progn                              ;Add user to the list
      (! from #(messenger logged-on))
      (cons (tuple from name) user-list))))

;;; Server deletes a user from the user list

(defun server-logoff (pid user-list)
  (lists:keydelete pid 1 user-list))

;;; Server transfers a message between user

(defun server-transfer (from-pid to-name message user-list)
  ;; Check that the user is logged on and who he is
  (case (lists:keyfind from-pid 1 user-list)
    ((tuple from-pid from-name)
     (server-transfer from-pid from-name to-name message user-list))
    ('false
     (! from-pid #(messenger stop you-are-not-logged-on)))))

;;; If the user exists, send the message

(defun server-transfer (from-pid from-name to-name message user-list)
  ;; Find the receiver and send the message
  (case (lists:keyfind to-name 2 user-list)
    ((tuple to-pid to-name)
     (! to-pid (tuple 'message-from from-name message))
     (! from-pid #(messenger sent)))
    ('false
     (! from-pid #(messenger receiver-not-found)))))

;;; User Commands

(defun logon (name)
  (case (whereis 'mess-client)
    ('undefined
     (let ((client (spawn 'messenger 'client (list (server-node) name))))
       (register 'mess-client client)))
    (_ 'already-logged-on)))

(defun logoff ()
  (! 'mess-client 'logoff))

(defun message (to-name message)
  (case (whereis 'mess-client)          ;Test if the client is running
    ('undefined
     'not-logged-on)
    (_  (! 'mess-client (tuple 'message-to to-name message))
        'ok)))

;;; The client process which runs on each server node

(defun client (server-node name)
  (! (tuple 'messenger server-node) (tuple (self) 'logon name))
  (await-result)
  (client server-node))

(defun client (server-node)
  (receive
    ('logoff
     (! (tuple 'messenger server-node) (tuple (self) 'logoff))
     (exit 'normal))
    ((tuple 'message-to to-name message)
     (! (tuple 'messenger server-node)
        (tuple (self) 'message-to to-name message))
     (await-result))
    ((tuple 'message-from from-name message)
     (lfe_io:format &quot;Message from ~p: ~p~n&quot; (list from-name message))))
  (client server-node))

;;; Wait for a response from the server

(defun await-result ()
  (receive
    ((tuple 'messenger 'stop why)       ;Stop the client
     (lfe_io:format &quot;~p~n&quot; (list why))
     (exit 'normal))
    ((tuple 'messenger what)            ;Normal response
     (lfe_io:format &quot;~p~n&quot; (list what)))))
</code></pre>
<p>To use this program you need to:</p>
<ul>
<li>configure the server_node() function</li>
<li>copy the compiled code (<code>messenger.beam</code>) to the directory on each computer where you start Erlang.</li>
</ul>
<p>In the following example of use of this program, I have started nodes on four different computers, but if you don't have that many machines available on your network, you could start up several nodes on the same machine.</p>
<p>We start up four Erlang nodes, messenger@super, c1@bilbo, c2@kosken, c3@gollum.</p>
<p>First we start up a the server at messenger@super:</p>
<pre><code class="language-lisp">(messenger@super)lfe&gt; (messenger:start-server)
true
</code></pre>
<p>Now Peter logs on at c1@bilbo:</p>
<pre><code class="language-lisp">(c1@bilbo)lfe&gt; (messenger:logon 'peter)
true
logged-on
</code></pre>
<p>James logs on at c2@kosken:</p>
<pre><code class="language-lisp">(c2@kosken)lfe&gt; (messenger:logon 'james)
true
logged-on
</code></pre>
<p>and Fred logs on at c3@gollum:</p>
<pre><code class="language-lisp">(c3@gollum)lfe&gt; (messenger:logon 'fred)
true
logged-on
</code></pre>
<p>Now Peter sends Fred a message:</p>
<pre><code class="language-lisp">(c1@bilbo)lfe&gt; (messenger:message 'fred &quot;hello&quot;)
ok
sent
</code></pre>
<p>And Fred receives the message and sends a message to Peter and logs off:</p>
<pre><code class="language-lisp">Message from peter: &quot;hello&quot;
(c3@gollum)lfe&gt; (messenger:message 'peter &quot;go away, I'm busy&quot;)
ok
sent
(c3@gollum)lfe&gt; (messenger:logoff)
logoff
</code></pre>
<p>James now tries to send a message to Fred:</p>
<pre><code class="language-lisp">(c2@kosken)lfe&gt; (messenger:message 'fred &quot;peter doesn't like you&quot;)
ok
receiver-not-found
</code></pre>
<p>But this fails as Fred has already logged off.</p>
<p>First let's look at some of the new concepts we have introduced.</p>
<p>There are two versions of the <code>server-transfer</code> function, one with four arguments (<code>server-transfer/4</code>) and one with five (<code>server_transfer/5</code>). These are regarded by LFE as two separate functions.</p>
<p>Note how we write the <code>server</code> function so that it calls itself, <code>(server user-list)</code> and thus creates a loop. The ErlangLFE compiler is &quot;clever&quot; and optimizes the code so that this really is a sort of loop and not a proper function call. But this only works if there is no code after the call, otherwise the compiler will expect the call to return and make a proper function call. This would result in the process getting bigger and bigger for every loop.</p>
<p>We use functions in the <code>lists</code> module. This is a very useful module and a study of the manual page is recommended (erl -man lists). <code>(lists:keymember key position lists)</code> looks through a list of tuples and looks at <code>position</code> in each tuple to see if it is the same as <code>key</code>. The first element is position 1. If it finds a tuple where the element at <code>position</code> is the same as <code>key</code>, it returns <code>true</code>, otherwise <code>false</code>.</p>
<pre><code class="language-lisp">&gt; (lists:keymember 'a 2 '(#(x y z) #(b b b) #(b a c) #(q r s)))
true
&gt; (lists:keymember 'p 2 '(#(x y z) #(b b b) #(b a c) #(q r s)))
false
</code></pre>
<p><code>lists:keydelete</code> works in the same way but deletes the first tuple found (if any) and returns the remaining list:</p>
<pre><code class="language-lisp">&gt; (lists:keymember 'a 2 '(#(x y z) #(b b b) #(b a c) #(q r s)))
(#(x y z) #(b b b) #(q r s))
</code></pre>
<p><code>lists:keyfind</code> is like <code>lists:keymember</code>, but it returns the tuple found or the atom <code>false</code>:</p>
<pre><code class="language-lisp">&gt; (lists:keyfind 'a 2 '(#(x y z) #(b b b) #(b a c) #(q r s)))
#(b a c)
&gt; (lists:keyfind 'p 2 '(#(x y z) #(b b b) #(b a c) #(q r s)))
false
</code></pre>
<p>There are a lot more very useful functions in the <code>lists</code> module.</p>
<p>An LFE process will (conceptually) run until it does a <code>receive</code> and there is no message which it wants to receive in the message queue. I say &quot;conceptually&quot; because the LFE system shares the CPU time between the active processes in the system.</p>
<p>A process terminates when there is nothing more for it to do, i.e. the last function it calls simply returns and doesn't call another function. Another way for a process to terminate is for it to call <code>exit/1</code>. The argument to <code>exit/1</code> has a special meaning which we will look at later. In this example we will do <code>(exit 'normal)</code> which has the same effect as a process running out of functions to call.</p>
<p>The BIF <code>(whereis registered-name)</code> checks if a registered process of name <code>registered-name</code> exists and return the pid of the process if it does exist or the atom <code>undefined</code> if it does not.</p>
<p>You should by now be able to understand most of the code above so I'll just go through one case: a message is sent from one user to another.</p>
<p>The first user &quot;sends&quot; the message in the example above by:</p>
<pre><code class="language-lisp">(messenger:message 'fred &quot;hello&quot;)
</code></pre>
<p>After testing that the client process exists:</p>
<pre><code class="language-lisp">(whereis 'mess-client)
</code></pre>
<p>and a message is sent to <code>mess-client</code>:</p>
<pre><code class="language-lisp">(! 'mess-client #(message-to fred &quot;hello&quot;))
</code></pre>
<p>The client sends the message to the server by:</p>
<pre><code class="language-lisp">(! #(messenger messenger@renat) (tuple (self) 'message-to 'fred &quot;hello&quot;))
</code></pre>
<p>and waits for a reply from the server.</p>
<p>The server receives this message and calls:</p>
<pre><code class="language-lisp">(server-transfer from 'fred &quot;hello&quot; user-list)
</code></pre>
<p>which checks that the pid <code>from</code> is in the <code>user-list</code>:</p>
<pre><code class="language-lisp">(lists:keyfind from 1 user-list)
</code></pre>
<p>If <code>keyfind</code> returns the atom <code>false</code>, some sort of error has occurred and the server sends back the message:</p>
<pre><code class="language-lisp">(! from-pid #(messenger stop you-are-not-logged-on))
</code></pre>
<p>which is received by the client which in turn does <code>(exit 'normal)</code> and terminates. If <code>keyfind</code> returns <code>(tuple from name)</code> we know that the user is logged on and is his name (peter) is in variable <code>name</code>. We now call:</p>
<pre><code class="language-lisp">(server-transfer from 'peter 'fred &quot;hello&quot; user-list)
</code></pre>
<p>Note that as this is <code>server-transfer/5</code> it is not the same as the previous function <code>server_transfer/4</code>. We do another <code>keyfind</code> on <code>user-list</code> to find the pid of the client corresponding to fred:</p>
<pre><code class="language-lisp">(lists:keyfind 'fred 2 user-list)
</code></pre>
<p>This time we use argument 2 which is the second element in the tuple. If this returns the atom <code>false</code> we know that fred is not logged on and we send the message:</p>
<pre><code class="language-lisp">(! from-pid #(messenger receiver-not-found)
</code></pre>
<p>which is received by the client, if <code>keyfind</code> returns:</p>
<pre><code class="language-lisp">(tuple to-pid 'fred)
</code></pre>
<p>we send the message:</p>
<pre><code class="language-lisp">(! to-pid #(message-from peter &quot;hello&quot;))
</code></pre>
<p>to fred's client and the message:</p>
<pre><code class="language-lisp">(! from-pid #(messenger sent))
</code></pre>
<p>to peter's client.</p>
<p>Fred's client receives the message and prints it:</p>
<pre><code class="language-lisp">((tuple 'message-from from-name message)
 (lfe_io:format &quot;Message from ~p: ~p~n&quot; (list from-name message))))
</code></pre>
<p>and peter's client receives the message in the <code>await-result</code> function.</p>
<h1><a class="header" href="#robustness" id="robustness">Robustness</a></h1>
<p>There are several things which are wrong with the <a href="robust/../concurrent/example.html">messenger example</a> from the previous chapter. For example if a node where a user is logged on goes down without doing a log off, the user will remain in the server's <code>user-list</code> but the client will disappear thus making it impossible for the user to log on again as the server thinks the user already logged on.</p>
<p>Or what happens if the server goes down in the middle of sending a message leaving the sending client hanging for ever in the <code>await-result</code> function?</p>
<h2><a class="header" href="#timeouts" id="timeouts">Timeouts</a></h2>
<p>Before improving the messenger program we will look into some general principles, using the ping pong program as an example. Recall that when &quot;ping&quot; finishes, it tells &quot;pong&quot; that it has done so by sending the atom <code>finished</code> as a message to &quot;pong&quot; so that &quot;pong&quot; could also finish. Another way to let &quot;pong&quot; finish, is to make &quot;pong&quot; exit if it does not receive a message from ping within a certain time, this can be done by adding a <em>timeout</em> to pong as shown in the following example:</p>
<pre><code class="language-lisp">(defmodule tut19
  (export (start-ping 1) (start-pong 0) (ping 2) (pong 0)))

(defun ping
  ((0 pong-node)
   (lfe_io:format &quot;Ping finished~n&quot; ()))
  ((n pong-node)
   (! (tuple 'pong pong-node) (tuple 'ping (self)))
   (receive
     ('pong (lfe_io:format &quot;Ping received pong~n&quot; ())))
   (ping (- n 1) pong-node)))

(defun pong ()
  (receive
    ((tuple 'ping ping-pid)
     (lfe_io:format &quot;Pong received ping~n&quot; ())
     (! ping-pid 'pong)
     (pong))
    (after 5000
      (lfe_io:format &quot;Pong timed out~n&quot; ()))))

(defun start-pong ()
  (register 'pong (spawn 'tut19 'pong ())))

(defun start-ping (pong-node)
  (spawn 'tut19 'ping (list 3 pong-node)))
</code></pre>
<p>After we have compiled this and copied the <code>tut19.beam</code> file to the necessary directories:</p>
<p>On (pong@kosken):</p>
<pre><code class="language-lisp">(pong@kosken)lfe&gt; (tut19:start-pong)
true
Pong received ping
Pong received ping
Pong received ping
Pong timed out
</code></pre>
<p>On (ping@gollum):</p>
<pre><code class="language-lisp">(ping@renat)lfe&gt; (tut19:start-ping 'pong@kosken)
&lt;0.40.0&gt;
Ping received pong
Ping received pong
Ping received pong
Ping finished
</code></pre>
<p>The timeout is set in:</p>
<pre><code class="language-lisp">(defun pong ()
  (receive
    ((tuple 'ping ping-pid)
     (lfe_io:format &quot;Pong received ping~n&quot; ())
     (! ping-pid 'pong)
     (pong))
    (after 5000
      (lfe_io:format &quot;Pong timed out~n&quot; ()))))
</code></pre>
<p>We start the timeout <code>(after 5000)</code> when we enter <code>receive</code>. The timeout is canceled if <code>#(ping ping-pid)</code> is received. If <code>#(ping ping-pid)</code> is not received, the actions following the timeout will be done after 5000 milliseconds. <code>after</code> must be last in the <code>receive</code>, i.e. preceded by all other message reception specifications in the <code>receive</code>. Of course we could also call a function which returned an integer for the timeout:</p>
<pre><code class="language-lisp">(after (pong-timeout)
</code></pre>
<p>In general, there are better ways than using timeouts to supervise parts of a distributed Erlang system. Timeouts are usually appropriate to supervise external events, for example if you have expected a message from some external system within a specified time. For example, we could use a timeout to log a user out of the messenger system if they have not accessed it, for example, in ten minutes.</p>
<h2><a class="header" href="#error-handling" id="error-handling">Error Handling</a></h2>
<p>Before we go into details of the supervision and error handling in an LFE system, we need see how LFE processes terminate, or in LFE terminology, <em>exit</em>.</p>
<p>A process which executes <code>(exit 'normal)</code> or simply runs out of things to do has a <em>normal</em> exit.</p>
<p>A process which encounters a runtime error (e.g. divide by zero, bad match, trying to call a function which doesn't exist etc) exits with an error, i.e. has an <em>abnormal</em> exit. A process which executes <code>(exit reason)</code> where <code>reason</code> is any LFE term except the atom <code>normal</code>, also has an abnormal exit.</p>
<p>An LFE process can set up links to other LFE processes. If a process calls <code>(link other-pid)</code> it sets up a bidirectional link between itself and the process called <code>other-pid</code>. When a process terminates, it sends something called a <em>signal</em> to all the processes it has links to.</p>
<p>The signal carries information about the pid it was sent from and the exit reason.</p>
<p>The default behaviour of a process which receives a normal exit is to ignore the signal.</p>
<p>The default behaviour in the two other cases (i.e. abnormal exit) above is to bypass all messages to the receiving process and to kill it and to propagate the same error signal to the killed process' links. In this way you can connect all processes in a transaction together using links and if one of the processes exits abnormally, all the processes in the transaction will be killed. As we often want to create a process and link to it at the same time, there is a special BIF, <code>spawn_link</code> which does the same as spawn, but also creates a link to the spawned process.</p>
<p>Now an example of the ping pong example using links to terminate &quot;pong&quot;:</p>
<pre><code class="language-lisp">(defmodule tut20
  (export (start 1) (ping 2) (pong 0)))

(defun ping (n pong-pid)
  (link pong-pid)
  (ping1 n pong-pid))

(defun ping1
  ((0 pong-pid)
   (exit 'ping))
  ((n pong-pid)
   (! pong-pid (tuple 'ping (self)))
   (receive
     ('pong (lfe_io:format &quot;Ping received pong~n&quot; ())))
   (ping1 (- n 1) pong-pid)))

(defun pong ()
  (receive
    ((tuple 'ping ping-pid)
     (lfe_io:format &quot;Pong received ping~n&quot; ())
     (! ping-pid 'pong)
     (pong))))

(defun start (ping-node)
  (let ((pong-pid (spawn 'tut20 'pong ())))
    (spawn ping-node 'tut20 'ping (list 3 pong-pid))))
</code></pre>
<pre><code class="language-lisp">(s1@bill)lfe&gt; (tut20:start 's2@kosken)
Pong received ping
&lt;5627.43.0&gt;
Ping received pong
Pong received ping
Ping received pong
Pong received ping
Ping received pong
</code></pre>
<p>This is a slight modification of the ping pong program where both processes are spawned from the same <code>start/1</code> function, where the &quot;ping&quot; process can be spawned on a separate node. Note the use of the <code>link</code> BIF. &quot;Ping&quot; calls <code>(exit `ping)</code> when it finishes and this will cause an exit signal to be sent to &quot;pong&quot; which will also terminate.</p>
<p>It is possible to modify the default behaviour of a process so that it does not get killed when it receives abnormal exit signals, but all signals will be turned into normal messages on the format <code>#(EXIT from-pid reason)</code> and added to the end of the receiving processes message queue. This behaviour is set by:</p>
<pre><code class="language-lisp">(process_flag 'trap_exit 'true)
</code></pre>
<p>There are several other process flags, see <em>erlang manual</em>. Changing the default behaviour of a process in this way is usually not done in standard user programs, but is left to the supervisory programs in OTP (but that's another tutorial). However we will modify the ping pong program to illustrate exit trapping.</p>
<pre><code class="language-lisp">(defmodule tut21
  (export (start 1) (ping 2) (pong 0)))

(defun ping (n pong-pid)
  (link pong-pid)
  (ping1 n pong-pid))

(defun ping1
  ((0 pong-pid)
   (exit 'ping))
  ((n pong-pid)
   (! pong-pid (tuple 'ping (self)))
   (receive
     ('pong (lfe_io:format &quot;Ping received pong~n&quot; ())))
   (ping1 (- n 1) pong-pid)))

(defun pong ()
  (process_flag 'trap_exit 'true)
  (pong1))

(defun pong1 ()
  (receive
    ((tuple 'ping ping-pid)
     (lfe_io:format &quot;Pong received ping~n&quot; ())
     (! ping-pid 'pong)
     (pong1))
    ((tuple 'EXIT from reason)
     (lfe_io:format &quot;Pong exiting, got ~p~n&quot;
		    (list (tuple 'EXIT from reason))))))

(defun start (ping-node)
  (let ((pong-pid (spawn 'tut21 'pong ())))
    (spawn ping-node 'tut21 'ping (list 3 pong-pid))))
</code></pre>
<pre><code class="language-lisp">(s1@bill)lfe&gt; (tut21:start 's2@kosken)
&lt;5627.44.0&gt;
Pong received ping
Ping received pong
Pong received ping
Ping received pong
Pong received ping
Ping received pong
Pong exiting, got #(EXIT &lt;5627.44.0&gt; ping)
</code></pre>
<h2><a class="header" href="#example-robust-messenger" id="example-robust-messenger">Example: Robust Messenger</a></h2>
<p>Now we return to the messenger program and add changes which make it more robust:</p>
<pre><code class="language-lisp">;;; Message passing utility.  
;;; User interface:
;;; (logon name)
;;;     One user at a time can log in from each Erlang node in the
;;;     system messenger: and choose a suitable name. If the name
;;;     is already logged in at another node or if someone else is
;;;     already logged in at the same node, login will be rejected
;;;     with a suitable error message.
;;; (logoff)
;;;     Logs off anybody at at node
;;; (message to-name message)
;;;     sends message to to-name. Error messages if the user of this 
;;;     function is not logged on or if to-name is not logged on at
;;;     any node.
;;;
;;; One node in the network of Erlang nodes runs a server which maintains
;;; data about the logged on users. The server is registered as &quot;messenger&quot;
;;; Each node where there is a user logged on runs a client process registered
;;; as &quot;mess-client&quot; 
;;;
;;; Protocol between the client processes and the server
;;; ----------------------------------------------------
;;; 
;;; To server: (tuple client-pid 'logon user-name)
;;; Reply #(messenger stop user-exists-at-other-node) stops the client
;;; Reply #(messenger logged-on) logon was successful
;;;
;;; When the client terminates for some reason
;;; To server: (tuple 'EXIT client-pid reason)
;;;
;;; To server: (tuple client-pid 'message-to to-name message) send a message
;;; Reply: #(messenger stop you-are-not-logged-on) stops the client
;;; Reply: #(messenger receiver-not-found) no user with this name logged on
;;; Reply: #(messenger sent) message has been sent (but no guarantee)
;;;
;;; To client: (tuple 'message-from name message)
;;;
;;; Protocol between the &quot;commands&quot; and the client
;;; ----------------------------------------------
;;;
;;; Started: (messenger:client server-node name)
;;; To client: logoff
;;; To client: (tuple 'message-to to-name message)
;;;
;;; Configuration: change the server-node() function to return the
;;; name of the node where the messenger server runs

(defmodule messenger
  (export (start-server 0) (server 0)
          (logon 1) (logoff 0) (message 2) (client 2)))

;;; Change the function below to return the name of the node where the
;;; messenger server runs

(defun server-node () 'messenger@renat)

;;; This is the server process for the &quot;messenger&quot;
;;; the user list has the format [{ClientPid1, Name1},{ClientPid22, Name2},...]

(defun server ()
  (process_flag 'trap_exit 'true)
  (server ()))

(defun server (user-list)
  (receive
    ((tuple from 'logon name)
     (let ((new-user-list (server-logon from name user-list)))
       (server new-user-list)))
    ((tuple 'EXIT from _)
     (let ((new-user-list (server-logoff from user-list)))
       (server new-user-list)))
    ((tuple from 'message-to to message)
     (server-transfer from to message user-list)
     (lfe_io:format &quot;list is now: ~p~n&quot; (list user-list))
     (server user-list))))

;;; Start the server

(defun start-server ()
  (register 'messenger (spawn 'messenger 'server '())))

;;; Server adds a new user to the user list

(defun server-logon (from name user-list)
  ;; Check if logged on anywhere else
  (if (lists:keymember name 2 user-list)
    (progn                              ;Reject logon
      (! from #(messenger stop user-exists-at-other-node))
      user-list)
    (progn                              ;Add user to the list
      (! from #(messenger logged-on))
      (link from)
      (cons (tuple from name) user-list))))

;;; Server deletes a user from the user list

(defun server-logoff (pid user-list)
  (lists:keydelete pid 1 user-list))

;;; Server transfers a message between user

(defun server-transfer (from-pid to-name message user-list)
  ;; Check that the user is logged on and who he is
  (case (lists:keyfind from-pid 1 user-list)
    ((tuple from-pid from-name)
     (server-transfer from-pid from-name to-name message user-list))
    ('false
     (! from-pid #(messenger stop you-are-not-logged-on)))))

;;; If the user exists, send the message

(defun server-transfer (from-pid from-name to-name message user-list)
  ;; Find the receiver and send the message
  (case (lists:keyfind to-name 2 user-list)
    ((tuple to-pid to-name)
     (! to-pid (tuple 'message-from from-name message))
     (! from-pid #(messenger sent)))
    ('false
     (! from-pid #(messenger receiver-not-found)))))

;;; User Commands

(defun logon (name)
  (case (whereis 'mess-client)
    ('undefined
     (let ((client (spawn 'messenger 'client (list (server-node) name))))
       (register 'mess-client client)))
    (_ 'already-logged-on)))

(defun logoff ()
  (! 'mess-client 'logoff))

(defun message (to-name message)
  (case (whereis 'mess-client)          ;Test if the client is running
    ('undefined
     'not-logged-on)
    (_  (! 'mess-client (tuple 'message-to to-name message))
        'ok)))

;;; The client process which runs on each server node

(defun client (server-node name)
  (! (tuple 'messenger server-node) (tuple (self) 'logon name))
  (await-result)
  (client server-node))

(defun client (server-node)
  (receive
    ('logoff
     (exit 'normal))
    ((tuple 'message-to to-name message)
     (! (tuple 'messenger server-node)
        (tuple (self) 'message-to to-name message))
     (await-result))
    ((tuple 'message-from from-name message)
     (lfe_io:format &quot;Message from ~p: ~p~n&quot; (list from-name message))))
  (client server-node))

;;; Wait for a response from the server

(defun await-result ()
  (receive
    ((tuple 'messenger 'stop why)       ;Stop the client 
     (lfe_io:format &quot;~p~n&quot; (list why))
     (exit 'normal))
    ((tuple 'messenger what)            ;Normal response
     (lfe_io:format &quot;~p~n&quot; (list what)))
    (after 5000
      (lfe_io:format &quot;No response from server~n&quot; ())
      (exit 'timeout))))
</code></pre>
<p>We have added the following changes:</p>
<p>The messenger server traps exits. If it receives an exit signal, <code>#(EXIT from reason)</code> this means that a client process has terminated or is unreachable because:</p>
<ul>
<li>the user has logged off (we have removed the &quot;logoff&quot; message),</li>
<li>the network connection to the client is broken,</li>
<li>the node on which the client process resides has gone down, or</li>
<li>the client processes has done some illegal operation.</li>
</ul>
<p>If we receive an exit signal as above, we delete the tuple, <code>#(from name)</code> from the servers <code>user-list</code> using the <code>server-logoff</code> function. If the node on which the server runs goes down, an exit signal (automatically generated by the system), will be sent to all of the client processes: <code>#(EXIT messenger-pid noconnection)</code> causing all the client processes to terminate.</p>
<p>We have also introduced a timeout of five seconds in the <code>await-result</code> function. I.e. if the server does not reply within five seconds (5000 ms), the client terminates. This is really only needed in the logon sequence before the client and server are linked.</p>
<p>An interesting case is if the client was to terminate before the server links to it. This is taken care of because linking to a non-existent process causes an exit signal, <code>#(EXIT from noproc)</code>, to be automatically generated as if the process terminated immediately after the link operation.</p>
<h1><a class="header" href="#records" id="records">Records</a></h1>
<p>[forthcoming]</p>
<p>Ticket: <a href="https://github.com/lfe/tutorial/issues/9">https://github.com/lfe/tutorial/issues/9</a></p>
<h2><a class="header" href="#modularising" id="modularising">Modularising</a></h2>
<p>[forthcoming]</p>
<p>Ticket: <a href="https://github.com/lfe/tutorial/issues/9">https://github.com/lfe/tutorial/issues/9</a></p>
<h2><a class="header" href="#header-files" id="header-files">Header Files</a></h2>
<p>[forthcoming]</p>
<p>Ticket: <a href="https://github.com/lfe/tutorial/issues/9">https://github.com/lfe/tutorial/issues/9</a></p>
<h2><a class="header" href="#records-1" id="records-1">Records</a></h2>
<p>A record is defined as:</p>
<pre><code class="language-lisp">(defrecord &lt;name-of-record&gt; &lt;field-name-1&gt; &lt;field-name-2&gt; ...)
</code></pre>
<p>The <code>defrecord</code> macro creates a number of new macro for creating, matching and accessing the fields of the record.</p>
<p>For example:</p>
<pre><code class="language-lisp">(defrecord message-to to-name message)
</code></pre>
<p>The record data is a tuple which is exactly equivalent to:</p>
<pre><code class="language-lisp">#(message-to &lt;to-name&gt; &lt;message&gt;)
</code></pre>
<p>Creating record is done with a <code>make-&lt;record-name&gt;</code> macro, and is best illustrated by an example:</p>
<pre><code class="language-lisp">(make-message-to message &quot;hello&quot; to-name 'fred)
</code></pre>
<p>This will create the tuple:</p>
<pre><code class="language-lisp">#(message-to fred &quot;hello&quot;)
</code></pre>
<p>Note that you don't have to worry about the order you assign values to the various parts of the records when you create it. The advantage of using records is that by placing their definitions in header files you can conveniently define interfaces which are easy to change. For example, if you want to add a new field to the record, you will only have to change the code where the new field is used and not at every place the record is referred to. If you leave out a field when creating a record, it will get the value of the atom <code>undefined</code>. (<em>manual</em>)</p>
<p>Pattern matching with records is very similar to creating records. For example inside a function clause, case or receive:</p>
<pre><code class="language-lisp">(match-message-to to-name the-name message the-message)
</code></pre>
<p>will match a <code>message-to</code> record and extract the <code>to-name</code> field in to the variable <code>the-name</code> and the <code>message</code> field in to the variable <code>the-message</code>. It is equivalent to writing:</p>
<pre><code class="language-lisp">(tuple 'message-to the-name the-message)
</code></pre>
<p>Accessing the fields of a record is done through macros which are created when the record is defined. For example the variable <code>my-message</code> contains a <code>message-to</code> record then</p>
<pre><code class="language-lisp">(message-to-message my-message)
</code></pre>
<p>will return the value of the <code>message</code> field of <code>my-message</code> and</p>
<pre><code class="language-lisp">(set-message-to-message my-message &quot;goodbye&quot;)
</code></pre>
<p>will return a new record where the <code>message</code> field now has the value <code>&quot;goodbye&quot;</code>.</p>
<h1><a class="header" href="#macros" id="macros">Macros</a></h1>
<p>As LFE code is just lists so it seems natural that there should be some way to evaluate data structures. In this chapter we will look at some ways of doing this.</p>
<h2><a class="header" href="#eval" id="eval">Eval</a></h2>
<p>The form <code>eval</code> takes an LFE data structure and evaluates it as an expression and then returns the value:</p>
<pre><code class="language-lisp">lfe&gt; (eval 15)
15
lfe&gt; (eval '(+ 1 2 3 4))
10
lfe&gt; (eval '(list 'a 'b 'c))
(a b c)
</code></pre>
<p>Using <code>eval</code> is one way way to merge lists and code. However, it is not a very good way:</p>
<ul>
<li>
<p>It is inefficient as the input expression is evaluated by the LFE interpreter, <code>lfe_eval</code>. This is much slower than running compiled code.</p>
</li>
<li>
<p>The expression is evaluated without a lexical context. So calling <code>eval</code> inside a <code>let</code> does not allow the evaluated expression to refer to variables bound by the <code>let</code>:</p>
</li>
</ul>
<pre><code class="language-lisp">lfe&gt; (set expr '(* x y))                   ; Expression to evaluate
(* x y)
lfe&gt; (let ((x 17) (y 42)) (eval expr))
exception error: #(unbound_symb x)

</code></pre>
<p>Well, this is not quite true. If we &quot;reverse&quot; the code and build a <code>let</code> expression which imports and binds the variables and then call <code>eval</code> on it we can access the variables:</p>
<pre><code class="language-lisp">lfe&gt; (eval (list 'let (list (list 'x 17) (list 'y 42)) expr))
714
</code></pre>
<h2><a class="header" href="#macros-1" id="macros-1">Macros</a></h2>
<p>The most common way to write programs in LFE that write programs is by defining macros. <em>Macros</em> work by transformation. When you define a macro you say how a call to it should be translated, the <em>macro expansion</em>, which is then done automatically by the compile. The code generated by the macro then becomes an integral part of the program.</p>
<p>Macros are usually defined with the <code>defmacro</code> form. It resembles a <code>defun</code> but instead of defining the value a call returns it defines how the call should be expanded. For example a macro <code>unless</code> which returns an expression which evaluates the <code>body</code> if the <code>test</code> is <code>false</code>:</p>
<pre><code class="language-lisp">(defmacro unless (test body)
  (list 'if (list 'not test) body))
</code></pre>
<p>So if we type into the toplevel REPL:</p>
<pre><code class="language-lisp">lfe&gt; (unless (&gt; 3 4) 'yes)
yes
lfe&gt; (unless (is_number 'foo) 'number)
number

</code></pre>
<p>To test a macro and look at its expansion we can use the function <code>macroexpand</code> which takes a macro call and generates its expansion<sup class="footnote-reference"><a href="#1">1</a></sup>:</p>
<pre><code class="language-lisp">lfe&gt; (macroexpand '(unless (&gt; 3 4) 'yes) $ENV)
(if (not (&gt; 3 4)) 'yes)
</code></pre>
<p>If a macro call expands into another macro call then the compiler or the toplevel REPL it will keep expanding until the expansion is no longer a macro. It is the expansion of the macro call which is then inserted into the code. So in the example of <code>unless</code> it is the resultant <code>if</code> form which is then inserted into the code.</p>
<hr />
<p><sup class="footnote-reference"><a href="#1">1</a></sup> The extra argument <code>$ENV</code> is needed as this is where the REPL keeps its locally defined functions and macros and we need to tell <code>macroexpand</code> where to look.</p>
<h2><a class="header" href="#the-backquote-macro" id="the-backquote-macro">The Backquote Macro</a></h2>
<p>The backquote macro makes it possible to build lists and tuples from templates. Used by itself a backquote is equivalent to a regular quote:</p>
<pre><code class="language-lisp">lfe&gt; `(a b c)
(a b c)
</code></pre>
<p>Like a regular quote, a backquote alone protects its arguments from evaluation. The advantage of backquote is that it is possible to turn on evaluation inside forms which are backquoted using <code>,</code> (comma or &quot;unquote&quot;) and <code>,@</code> (comma-at or &quot;unquote splice&quot;).<sup class="footnote-reference"><a href="#1">1</a></sup> When something is prefixed with a comma it will be evaluated. For example:</p>
<pre><code class="language-lisp">lfe&gt; (set (tuple a b) #(1 2))
#(1 2)
lfe&gt; `(a is ,a and b is ,b)
(a is 1 and b is 2)
lfe&gt; `#(a ,a b ,b)
#(a 1 b 2)
</code></pre>
<p>Quoting works with both lists and tuples. The backquote actually expands to an expression which builds the structure the templates describes. For example, the following</p>
<pre><code class="language-lisp">`(a is ,a and b is ,b)
</code></pre>
<p>expands to</p>
<pre><code class="language-lisp">(list 'a 'is a 'and b 'is b)
</code></pre>
<p>and</p>
<pre><code class="language-lisp">`(a . ,a)
</code></pre>
<p>expands to</p>
<pre><code class="language-lisp">(cons 'a a)
</code></pre>
<p>This:</p>
<pre><code class="language-lisp">`#(a ,a b ,b)
</code></pre>
<p>expands to</p>
<pre><code class="language-lisp">(tuple 'a a 'b b)
</code></pre>
<p>They are very useful in macros as we can write a macro definitions which look like the expansions they produce. For example we could define the <code>unless</code> from the previous section as:</p>
<pre><code class="language-lisp">(defmacro unless
  ((cons test body) `(if (not ,test) (progn ,@body))))
</code></pre>
<p>Here we have extended it allow multiple forms in the body. Comma-at is like comma but splices its argument which should be a list. So for example:</p>
<pre><code class="language-lisp">lfe&gt; (macroexpand '(unless (test x) (first-do) (second-do)) $ENV)
(if (not (test x)) (progn (first-do) (second-do)))
</code></pre>
<p>As the backquote macro expands to the expression which would build the template it is also very useful in patterns as we can use a template to describe the pattern. Here is the <a href="macros/../sequential/example.html">Converting Temperature</a> example rewritten to use backquote in both the patterns and constructors:</p>
<pre><code class="language-lisp">(defun f-&gt;c
  ((`#(,name #(C ,temp)))
    ;; No conversion needed
    `#(,name #(C ,temp)))
  ((`#(,name #(F ,temp)))
    ;; Do the conversion
    `#(,name #(C ,(/ (* (- temp 32) 5) 9)))))

(defun print-temp
  ((`#(,name #(C ,temp)))
    (lfe_io:format &quot;~-15w ~w C~n&quot; `(,name ,temp))))
</code></pre>
<p>Using the backquote macro also makes it much easier to build expressions which we can evaluate with <code>eval</code>. So if we want to import values into the expression to evaluate we can do it like this:</p>
<pre><code class="language-lisp">lfe&gt; (set expr '(* x y))                   ;Expression to evaluate
(* x y)
lfe&gt; (eval `(let ((x 17) (y 42)) ,expr))
714
</code></pre>
<hr />
<p><sup class="footnote-reference"><a href="#1">1</a></sup> In LFE the backquote is a normal macro and is expanded at the same time as other macros. When they are parsed <code> `thing</code> becomes <code>(backquote thing)</code>, <code>,thing</code> becomes <code>(comma thing)</code> and <code>,@thing</code> becomes <code>(comma-at thing)</code>.</p>
<h1><a class="header" href="#conclusion" id="conclusion">Conclusion</a></h1>
<p>[forthcoming]</p>
<p>Ticket: <a href="https://github.com/lfe/tutorial/issues/10">https://github.com/lfe/tutorial/issues/10</a></p>
<h1><a class="header" href="#feedback-and-docs-bugs" id="feedback-and-docs-bugs">Feedback and Docs Bugs</a></h1>
<p>If you would like to provide feedback about this guide, we would welcome the
chance to improve the experience for everyone. Please
<a href="https://github.com/lfe/tutorial/issues/new">create a ticket</a> in the
Github issue tracker. Be sure to give a full description so that we can best
help you!</p>
<meta http-equiv="refresh" content="0; URL=http://docs.lfe.io/" />
<meta http-equiv="refresh" content="0; URL=https://github.com/rust-lang/mdbook/" />

                </main>

                <nav class="nav-wrapper" aria-label="Page navigation">
                    <!-- Mobile navigation buttons -->
                    

                    

                    <div style="clear: both"></div>
                </nav>
            </div>
        </div>

        <nav class="nav-wide-wrapper" aria-label="Page navigation">
            

            
        </nav>

    </div>

    

    
    <!-- Google Analytics Tag -->
    <script type="text/javascript">
        var localAddrs = ["localhost", "127.0.0.1", ""];

        // make sure we don't activate google analytics if the developer is
        // inspecting the book locally...
        if (localAddrs.indexOf(document.location.hostname) === -1) {
            (function (i, s, o, g, r, a, m) {
            i['GoogleAnalyticsObject'] = r; i[r] = i[r] || function () {
                (i[r].q = i[r].q || []).push(arguments)
            }, i[r].l = 1 * new Date(); a = s.createElement(o),
                m = s.getElementsByTagName(o)[0]; a.async = 1; a.src = g; m.parentNode.insertBefore(a, m)
            })(window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga');

            ga('create', 'UA-38274766-4', 'auto');
            ga('send', 'pageview');
        }
    </script>
    

    

    
    <script type="text/javascript">
        window.playground_copyable = true;
    </script>
    

    

    
    <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
    

    <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
    <script src="book.js" type="text/javascript" charset="utf-8"></script>

    <!-- Custom JS scripts -->
    

    
    
    <script type="text/javascript">
        window.addEventListener('load', function () {
            window.setTimeout(window.print, 100);
        });
    </script>
    
    

</body>

</html>
